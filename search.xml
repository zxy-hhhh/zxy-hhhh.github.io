<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[yuanfangshu]]></title>
    <url>%2F2019%2F01%2F08%2Fyuanfangshu%2F</url>
    <content type="text"><![CDATA[圆方树此坑待填]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu-3676]]></title>
    <url>%2F2019%2F01%2F06%2Fluogu-3676%2F</url>
    <content type="text"><![CDATA[小清新数据结构题真是小清新 题意查询以$x$为根时的所有子树的权值和的平方和，带单点修改、 做法为了表达方便，记$q$为询问的点，我们用$x$表示$1$到$q$路径上的点 可以先$O(n)$的处理出以$1$为根时：​ 答案，记为$Ans$ ​ 每颗子树的权值和，记为$S_i$ ​ 所有点权值和，记为$Sum$ ​ 点的深度，记为$dep_i$，$dep_1=1$ 考虑修改修改点$q$，记原来值和当前值差为$d$ $Sum=Sum+dep_x*d$ $Ans=Ans-\sum\limits_x(S_x)^2+\sum\limits_x(S_x+d)^2$ $=Ans-\sum\limits_x(S_x)^2+\sum\limits_x(S_x)^2+2S_xd+d^2$ $=Ans+\sum\limits_{x}2S_xd+d^2$ $=Ans+2 d\sum\limits_x S_x+dep_x d^2$ 所有$S_x=S_x+d$ 当根换为$q$时此时点$x$，不含点$q$，$S_x$会变为$Sum-S_{son}$，$S_{son}$表示$x$的包含点$q$的子树的大小 其余点不变 所以答案为 $Ans-\sum\limits_x(S_x)^2+Sum^2+\sum\limits_x(Sum-S_x)^2$ $=Ans+\sum\limits_x(Sum-S_x)^2-(S_x)^2+Sum^2$ 平方差公式展开 $=Ans+Sum^2+\sum\limits Sum(Sum-2S_x)$ $=Ans+Sum^2+Sum\sum\limits Sum-2S_x$ $=Ans+Sum^2+Sum^2dep_x+2Sum\sum\limits S_x$ 用树剖+树状数组维护链上加，链上求和就好了 代码时间复杂度$O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/04*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 200005namespace Tree_Array&#123; ll sum[maxn],Sum[maxn]; int n; inline void add(int x,int val) &#123; for(int i=x;i&lt;=n;i+=i&amp;(-i)) sum[i]+=val,Sum[i]+=1ll*x*val; &#125; inline ll getsum(int x) &#123; ll ans=0; for(int i=x;i;i-=i&amp;(-i)) ans+=(x+1)*sum[i]-Sum[i]; return ans; &#125; inline void update(int l,int r,int x) &#123;add(l,x),add(r+1,-x);&#125; inline ll query(int l,int r)&#123;return getsum(r)-getsum(l-1);&#125;&#125;namespace Tree&#123; int n; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn],cnt; inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125; int top[maxn],sz[maxn],fa[maxn],son[maxn],dep[maxn]; int val[maxn],a[maxn]; int sum[maxn]; ll Ans,S; int idx[maxn],id; void dfs(int u) &#123; dep[u]=dep[fa[u]]+1,sz[u]=1;sum[u]=a[u]; cross(i,u) if (to[i]!=fa[u])&#123; fa[to[i]]=u,dfs(to[i]); sz[u]+=sz[to[i]],sum[u]+=sum[to[i]]; if (sz[son[u]]&lt;sz[to[i]]) son[u]=to[i]; &#125; &#125; void dfs(int u,int tp) &#123; idx[u]=++id;val[id]=a[u]; top[u]=tp; if (son[u]) dfs(son[u],tp); cross(i,u) if (to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs(to[i],to[i]); &#125; inline void init() &#123; dfs(1),dfs(1,1); Tree_Array::n=id; rep(i,1,id) Tree_Array::update(idx[i],idx[i],sum[i]),Ans+=sum[i]*sum[i]; S=sum[1]; &#125; inline void link_update(int x,ll val) &#123; while(1)&#123; Tree_Array::update(idx[top[x]],idx[x],val); if (top[x]==1) return ; x=fa[top[x]]; &#125; &#125; inline ll sigma(int x) &#123; ll ans=0; while(1)&#123; ans+=Tree_Array::query(idx[top[x]],idx[x]); if (top[x]==1) return ans; x=fa[top[x]]; &#125; &#125; inline ll query(int x) &#123;return Ans+S*S+1ll*dep[x]*S*S-2ll*S*sigma(x);&#125; inline void update(int x,ll val) &#123; ll delta=val-a[x],s1=sigma(x),s2=dep[x]; Ans+=2*s1*delta+delta*delta*dep[x]; S+=delta; link_update(x,delta); a[x]=val; &#125;&#125;using namespace Tree;int main()&#123; n=rd(); int m=rd(); rep(i,1,n-1) &#123; int x=rd(),y=rd(); add(x,y);add(y,x); &#125; rep(i,1,n) a[i]=rd(); init(); rep(_i,1,m)&#123; int op=rd(); if (op==1)&#123; int x=rd(),val=rd(); update(x,val); &#125; else &#123; int x=rd(); wrt(query(x),'\n'); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4573]]></title>
    <url>%2F2018%2F12%2F13%2Fbzoj4573%2F</url>
    <content type="text"><![CDATA[有趣的LCT题 写在前面的一些结论： 合法的$2$操作只会在一段连续的区间内发生，所以合法$2$操作也只会在一段区间内发生，因此我们可以把更换生长节点的区间，和加点区间取并，使$2$操作一定合法 如果$2$操作一定合法，加点操作区间从l~r变为1~n并不影响答案 一个询问在该询问进入时处理，和之后处理，答案并不改变，并且只有涉及到该树的操作才会对这个询问产生影响 结论是显然的 知道这些之后，来考虑如何解决； 一个想法可以基于上面结论，产生一个愚蠢的想法 设$x$为$2$操作后的生长节点，$y$为之前的 将$2$操作拆成两次： 在$l$处，将之后加入所有点，换到$x$下面 在$r+1$处,将之后加入所有点，换回$y$下面 然后将询问和$2$操作按位置排序，从1~n扫一遍，依次处理就得到了$O(n^{2})$的优秀做法 那么如何优化虚点!!!对每一个$2$操作建一个虚点，每个虚点的父节点是前一个虚点，第一个虚点的父亲是1 每一次加点就加到当前最后一个虚点下面就好了。 每次移动就直接将该$2$操作对应的虚点及其子树移到新的生长节点下然而还是T 统计答案我们让虚点权值为0，实点为1 设一个点i到根路径上权值和为 $S_{i}$(包含自身权值) $dis(u,v)=S_{u}+S_{v}-2S_{lca}$ 大家举几个栗子，想象一下，就知道这是对的。我不会证 LCT大法吼！！！移动子树相当于换父亲，LCT就可以了。 但是此处LCT 不能换根，因为有虚点，不同于普通树上路径，所以根的位置对答案会产生影响。 此处cut操作一定是儿子cut父亲，所以直接cut掉就可以了，like this1access(u);splay(u);fa[son[u][0]]=0,son[u][0]=0; 而link操作也一定是一颗树的根去link，所以也直接link就好了，像这样1access(v),splay(v),fa[v]=u; 然后就愉快的A了此题，时间复杂度$O(nlogn)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/* Author: zxy_hhhh date: 2018/12/07*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longinline ll rd() &#123; ll _x = 0; int _ch = getchar(), _f = 1; for (; !isdigit(_ch) &amp;&amp; (_ch != '-') &amp;&amp; (_ch != EOF); _ch = getchar()) ; if (_ch == '-') &#123; _f = 0; _ch = getchar(); &#125; for (; isdigit(_ch); _ch = getchar()) _x = _x * 10 + _ch - '0'; return _f ? _x : -_x;&#125;void write(ll _x) &#123; if (_x &gt;= 10) write(_x / 10), putchar(_x % 10 + '0'); else putchar(_x + '0');&#125;inline void wrt(ll _x, char _p) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 400005struct LCT &#123; int son[maxn][2], val[maxn], sum[maxn], fa[maxn], cnt; inline bool isroot(int x) &#123; return son[fa[x]][1] != x &amp;&amp; son[fa[x]][0] != x; &#125; inline void update(int x) &#123; sum[x] = sum[son[x][0]] + sum[son[x][1]] + val[x]; &#125; inline void rotate(int x) &#123; int y = fa[x], z = fa[y], d = son[y][1] == x; if (!isroot(y)) son[z][son[z][1] == y] = x; fa[y] = x, fa[x] = z; fa[son[x][!d]] = y, son[y][d] = son[x][!d]; son[x][!d] = y; update(y), update(x); &#125; inline void splay(int x) &#123; for (; !isroot(x);) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) (son[y][1] == x) ^ (son[z][1] == y) ? rotate(x) : rotate(y); rotate(x); &#125; &#125; inline int access(int x) &#123; int t = 0; for (; x; t = x, x = fa[x]) splay(x), son[x][1] = t, update(x); return t; &#125; inline void link(int u, int v) &#123; fa[v] = u; &#125;//因为先有cut所以可以不access inline void cut(int u) &#123; access(u); splay(u); fa[son[u][0]] = 0, son[u][0] = 0; &#125; inline int dis(int x, int y) &#123; int Sum = 0; access(x); splay(x); Sum += sum[x]; int lca = access(y); splay(y); Sum += sum[y]; access(lca); splay(lca); Sum -= sum[lca] &lt;&lt; 1; return Sum; &#125; inline void changefa( int x, int y) // xxc's fahter was hje before,but now his father is me &#123; cut(x); link(y, x); &#125; inline int getfather(int x) &#123; access(x); splay(x); return son[x][0]; &#125; inline int new_node(int x) &#123; sum[++cnt] = x, val[cnt] = x; return cnt; &#125;&#125; lct;int to[maxn];int cl[maxn], cr[maxn], ans[maxn];int n, m, p, r, cnt, QwQ;struct Query &#123; int op, w, x, y, id; bool operator&lt;(const Query &amp;B) const &#123; return (w &lt; B.w) || (w == B.w &amp;&amp; op &lt; B.op); &#125;&#125; Q[maxn &lt;&lt; 1];int main() &#123; n = rd(), m = rd(); to[1] = lct.new_node(1); lct.link(1, lct.new_node(0)); cl[1] = 1, cr[1] = n; int now = 2, w = 1; rep(i, 1, m) &#123; int op = rd(); if (op == 0) &#123; cl[++w] = rd(), cr[w] = rd(); lct.link(now, to[w] = lct.new_node(1)); &#125; else if (op == 1) &#123; int l = rd(), r = rd(), x = rd(), pre = now; l = std::max(l, cl[x]), r = std::min(r, cr[x]); if (l &gt; r) continue; now = lct.new_node(0); Q[++cnt].op = 1, Q[cnt].w = l, Q[cnt].x = now, Q[cnt].y = to[x]; Q[++cnt].op = 1, Q[cnt].w = r + 1, Q[cnt].x = now, Q[cnt].y = pre; lct.link(pre, now); &#125; else &#123; Q[++cnt].w = rd(); int x = rd(), y = rd(); Q[cnt].op = 2, Q[cnt].x = x, Q[cnt].y = y; Q[cnt].id = ++QwQ; &#125; &#125; std::sort(Q + 1, Q + 1 + cnt); rep(i, 1, cnt) &#123; if (Q[i].op == 1) lct.changefa(Q[i].x, Q[i].y); else ans[Q[i].id] = lct.dis(to[Q[i].x], to[Q[i].y]); &#125; rep(i, 1, QwQ) wrt(ans[i], '\n');&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about-zxy]]></title>
    <url>%2F2018%2F12%2F06%2Fabout-zxy%2F</url>
    <content type="text"><![CDATA[博客运行一段时间了，也有了一点文章了，该来个about me了 about我的ID我常以zxy_hhhh及地狱小鬼366(无法输入中文时为dyxg)的ID游荡于各大OJ、社交网站&amp;&amp;游戏 关于OI生涯去年拿了个pj1=，今天tg咕咕咕了不过1=还是有的；之后的么。。。待续 关于博客内容一般是一些题解或者对算法/数据结构的理解。 一些解释关于背景图都是妹子图，不过刷新一下会换一张，一共7张 关于加密文章虽然前端的加密是扯淡，是作为本人云剪切版用的，因为一些政治原因无法公开 分享功能是GG的，请勿使用虽然我觉得不会有人去用 关于访问速度问题，因为我部署在github上的，国内访问速度就。。。不过，过几天我说不定会往coding上部署一份，届时访问速度就会好多了 头像什么的还在搞。。。 如果有建议或意见或者要换友联，请用QQ或邮箱私信我，留言的话也可以，不过有我可能无法第一时间看到 先写这么多吧，其他的想到了再补]]></content>
  </entry>
  <entry>
    <title><![CDATA[初学树套树]]></title>
    <url>%2F2018%2F12%2F05%2Ftree-tao-tree%2F</url>
    <content type="text"><![CDATA[最近写了点树套树，感觉也没那么可怕 主要思想很多用于动态维护区间的一些东西，比如：区间内大于等于x的数的个数、区间前驱后继等等 主要思想很简单，就是 对外层树的每一个节点建一个内层树 具体实现方式可见例题 来几个 栗子K大数查询因为有区间修改，所以外层建权值线段树，内层建区间树 处理修改：对所有包含c的外层树节点所对应的内层树的a~b区间+1 处理询问：在外层树上二分，若当前节点的右子树的内层树a~b区间和&gt;c就往左子树走，否则往右 注意: 区间树要标记永久化，不然如果写的不够优秀会 MLE or TLE 此题luogu上时限只有1s，大部分代码包括本人代码会被卡常，获得0~100不等的分数。 在往左子树走时要减掉右子树a~b区间和带来的贡献 在具体实现的时候，我为了图方便用了指针和namespace 如果你看不懂指针，可以往下翻，有无指针的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* Author: zxy_hhhh date: 2018/12/01*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define mid ((l + r) &gt;&gt; 1)int n, m;namespace xtree &#123;struct node &#123; int lazy; ll sum; node *ls, *rs;&#125;;void insert(node *&amp;u, int l, int r, int ql, int qr) &#123; if (u == NULL) u = new node; if (ql == l &amp;&amp; r == qr) &#123; u-&gt;lazy++, u-&gt;sum += r - l + 1; return; &#125; u-&gt;sum += qr - ql + 1; if (qr &lt;= mid) insert(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) insert(u-&gt;rs, mid + 1, r, ql, qr); else insert(u-&gt;ls, l, mid, ql, mid), insert(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;ll query(node *u, int l, int r, int ql, int qr) &#123; if (u == NULL) return 0; if (ql == l &amp;&amp; qr == r) return u-&gt;sum; ll ans = (qr - ql + 1) * u-&gt;lazy; if (qr &lt;= mid) return ans + query(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) return ans + query(u-&gt;rs, mid + 1, r, ql, qr); else return query(u-&gt;ls, l, mid, ql, mid) + ans + query(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;&#125;; // namespace xtreenamespace ytree &#123;struct node &#123; xtree::node *rt;&#125; tr[400005];void insert(int pos, int l, int r, int ql, int qr, int x) &#123; xtree::insert(tr[pos].rt, 1, n, ql, qr); if (l == r) return; if (x &lt;= mid) insert(pos &lt;&lt; 1, l, mid, ql, qr, x); else insert(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;int query(int pos, int l, int r, int ql, int qr, ll x) &#123; if (l == r) return l; ll sum = xtree::query(tr[pos &lt;&lt; 1 | 1].rt, 1, n, ql, qr); if (sum &gt;= x) return query(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x); else return query(pos &lt;&lt; 1, l, mid, ql, qr, x - sum);&#125;&#125;; // namespace ytreestruct Query &#123; int op, l, r; ll c;&#125; Q[maxn];int H[maxn], tot;int main() &#123; n = rd(), m = rd(); rep(i, 1, m) &#123; int op = rd(), l = rd(), r = rd(); ll x = rd(); if (op == 1) ytree::insert(1, -n, n, l, r, x); if (op == 2) wrt(ytree::query(1, -n, n, l, r, x), '\n'); &#125;&#125; 二逼平衡树外层线段树，内层平衡树 操作1 4 5就是在线段树上取出区间，然后平衡树内求答案，合并答案 修改也没什么好讲的，和上一题比较相似 操作2要二分答案，然后转化为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* Author: zxy_hhhh date: 2018/12/03*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define inf 2147483647#define mid ( (l + r) &gt;&gt; 1 int a[maxn], n, m;namespace xtree &#123;struct node *nil;struct node &#123; int sz, val, fix; node *ls, *rs; node(int x) : sz(1), val(x), fix(rand()) &#123; ls = rs = nil; &#125; inline void update() &#123; sz = ls-&gt;sz + rs-&gt;sz + 1; &#125;&#125;;inline void init() &#123; nil = new node(0); nil-&gt;ls = nil-&gt;rs = nil; nil-&gt;sz = 0;&#125;void split(node *now, int k, node *&amp;x, node *&amp;y, int op = 1) &#123; if (now == nil) &#123; x = y = nil; return; &#125; if (op == 1 ? now-&gt;val &lt; k : now-&gt;ls-&gt;sz &lt; k) &#123; x = now; split(now-&gt;rs, (op == 1 ? k : k - now-&gt;ls-&gt;sz - 1), x-&gt;rs, y, op); x-&gt;update(); &#125; else &#123; y = now; split(now-&gt;ls, k, x, y-&gt;ls, op); y-&gt;update(); &#125;&#125;node *merge(node *x, node *y) &#123; if (x == nil) return y; if (y == nil) return x; if (x-&gt;fix &lt; y-&gt;fix) &#123; x-&gt;rs = merge(x-&gt;rs, y); return x-&gt;update(), x; &#125; else &#123; y-&gt;ls = merge(x, y-&gt;ls); return y-&gt;update(), y; &#125;&#125;inline void insert(node *&amp;rt, int val) &#123; node *x, *y; split(rt, val, x, y); rt = merge(x, merge(new node(val), y));&#125;inline void del(node *&amp;rt, int val) &#123; node *x, *y, *z; split(rt, val, x, y); split(y, 1, y, z, 2); rt = merge(x, z);&#125;inline int pre(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val, x, y), split(x, x-&gt;sz - 1, x, z, 2); if (z == nil) ans = -inf; else ans = (z-&gt;val); rt = merge(x, merge(z, y)); return ans;&#125;inline int nxt(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val + 1, x, y), split(y, 1, y, z, 2); if (y == nil) ans = inf; else ans = y-&gt;val; rt = merge(x, merge(y, z)); return ans;&#125;inline int rank(node *&amp;rt, int val) &#123; node *x, *y; int ans; split(rt, val, x, y); if (x == nil) ans = 0; else ans = x-&gt;sz; rt = merge(x, y); return ans;&#125;&#125; // namespace xtreenamespace ytree &#123;xtree::node *tr[maxn &lt;&lt; 2];inline int pre(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return -inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::pre(tr[pos], x); return max(pre(pos &lt;&lt; 1, l, mid, ql, qr, x), pre(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int nxt(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::nxt(tr[pos], x); return min(nxt(pos &lt;&lt; 1, l, mid, ql, qr, x), nxt(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int rank(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::rank(tr[pos], x); return rank(pos &lt;&lt; 1, l, mid, ql, qr, x) + rank(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;inline void change(int pos, int l, int r, int x, int v) &#123; xtree::del(tr[pos], a[x]), xtree::insert(tr[pos], v); if (l == r) return; if (x &lt;= mid) change(pos &lt;&lt; 1, l, mid, x, v); else change(pos &lt;&lt; 1 | 1, mid + 1, r, x, v);&#125;inline int atrank(int L, int R, int k) &#123; int l = 0, r = 100000000, ans; while (l &lt;= r) &#123; if (rank(1, 1, n, L, R, mid) &lt; k) ans = mid, l = mid + 1; else r = mid - 1; &#125; return ans;&#125;void build(int pos, int l, int r) &#123; tr[pos] = xtree::nil; rep(i, l, r) xtree::insert(tr[pos], a[i]); if (l == r) return; build(pos &lt;&lt; 1, l, mid), build(pos &lt;&lt; 1 | 1, mid + 1, r);&#125;&#125; // namespace ytreeint main() &#123; n = rd(); m = rd(); xtree::init(); rep(i, 1, n) a[i] = rd(); ytree::build(1, 1, n); rep(i, 1, m) &#123; int op = rd(); if (op == 1) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::rank(1, 1, n, l, r, x) + 1, '\n'); &#125; else if (op == 2) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::atrank(l, r, x), '\n'); &#125; else if (op == 3) &#123; int x = rd(), k = rd(); ytree::change(1, 1, n, x, k); a[x] = k; &#125; else if (op == 4) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::pre(1, 1, n, l, r, x), '\n'); &#125; else if (op == 5) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::nxt(1, 1, n, l, r, x), '\n'); &#125; &#125;&#125; 不勤劳的图书管理员暴力可以AC 先算出不修改时的答案； 对于的位置i贡献就是 $\Sigma_{j=1}^{j&lt;i} a[j]+a[i] (v[j]&gt;v[i])$ 然后对于每一次修改，考虑对答案的影响就是y移到x减少的和x移到y增加的而影响只会出现在(x,y) 具体就是： (x,y)对x产生的逆序对，y对(x,y)产生的逆序对会失去 (x,y)对y产生的逆序对，x对(x,y)产生的逆序对会增加入答案 如何维护a[i]+a[j]? 用树套树维护(x,y)大于等于x的数的个数和这些数的和 不能用指针，不然空间会GG 要外层树状数组内层线段树，不然空间GG 外层线段树内层平衡树空间OK的，不过时间就呵呵了机房某大佬卡了一上午常之后彻底弃疗，写了暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* Author: zxy_hhhh date: 2018/12/05*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define mod 1000000007#define mid ((l + r) &gt;&gt; 1)#define lb(x) (x &amp; -x)#define maxn 50005int n, a[maxn], w[maxn], m, Ans;inline int Mod(int x) &#123; return x &lt; 0 ? (x + mod) : (x &gt;= mod ? x - mod : x); &#125;namespace xtree &#123;struct node &#123; int sum,ls,rs;&#125;tr[20000000];int cnt;void insert(int &amp;u, int l, int r, int x, int k) &#123; if (!u) u = ++cnt; tr[u].sum = Mod(tr[u].sum + k); if (l == r) return; if (x &lt;= mid) insert(tr[u].ls, l, mid, x, k); else insert(tr[u].rs, mid + 1, r, x, k);&#125;inline int query(int u, int l, int r, int ql, int qr) &#123; if (!u) return 0; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u].sum; return (query(tr[u].ls, l, mid, ql, qr) + query(tr[u].rs, mid + 1, r, ql, qr)) % mod;&#125;&#125; // namespace xtreestruct &#123; int tr[maxn]; inline void update(int x, int k, int val) &#123; for (; x &lt;= n; x += lb(x)) xtree::insert(tr[x], 1, n, k, val); &#125; inline int query(int x, int L, int R) &#123; int ans = 0; for (; x; x -= lb(x)) ans = Mod(ans + xtree::query(tr[x], 1, n, L, R)); return ans; &#125; inline int query(int L, int R, int l, int r) &#123; return Mod(query(R, l, r) - query(L - 1, l, r)); &#125;&#125; tr1, tr2;int main() &#123; n = rd(), m = rd(); rep(i, 1, n) &#123; w[i] = rd(), a[i] = rd(); tr1.update(i, w[i], a[i]), tr2.update(i, w[i], 1); Ans = Mod(Ans + tr1.query(i - 1, w[i], n)), Ans = Mod(Ans + 1ll * tr2.query(i - 1, w[i], n) * a[i] % mod); &#125; rep(i, 1, m) &#123; int x = rd(), y = rd(); if (x &gt; y) swap(x, y); if (x==y) &#123;wrt(Ans,'\n');continue;&#125; Ans = Mod(Ans - tr1.query(x + 1, y - 1, w[y], n)); Ans = Mod(Ans + tr1.query(x + 1, y - 1, w[x], n)); Ans = Mod(Ans - tr1.query(x + 1, y - 1, 1, w[x])); Ans = Mod(Ans + tr1.query(x + 1, y - 1, 1, w[y])); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, w[y], n) * a[y] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, w[x], n) * a[x] % mod); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, 1, w[x]) * a[x] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, 1, w[y]) * a[y] % mod); if (w[x] &gt; w[y]) Ans -= a[x] + a[y]; else Ans += a[x] + a[y]; Ans=Mod(Ans); tr1.update(x, w[x], -a[x]), tr1.update(x, w[y], a[y]); tr1.update(y, w[y], -a[y]), tr1.update(y, w[x], a[x]); tr2.update(x, w[x], -1), tr2.update(x, w[y], 1); tr2.update(y, w[y], -1), tr2.update(y, w[x], 1); swap(w[x], w[y]), swap(a[x], a[y]); wrt(Ans, '\n'); &#125; //wrt(xtree::cnt,'\n');&#125; 先写到这里吧]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F11%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[暂时当更新日志用12.4 8:54 update头像好像出了点锅，先拿默认的顶一顶，争取晚上解决吧;其他基本解决12.5 15:53 update因为晚上断网了，所以头像咕咕咕了；我还是先写点东西吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[ss]]></title>
    <url>%2F1028%2F12%2F06%2Fmy-ss%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
  </entry>
</search>
