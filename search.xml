<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[contest0111]]></title>
    <url>%2F2019%2F01%2F11%2Fcontest0111%2F</url>
    <content type="text"><![CDATA[模拟赛 弹珠平衡树维护出序列； 后面部分使用单调栈维护下凸壳即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/11*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 500005#define maxval 1000000000namespace Treap &#123; int sz[maxn],ls[maxn],rs[maxn],fix[maxn],val[maxn],cnt,rt; inline void pushup(int x) &#123;sz[x]=sz[ls[x]]+sz[rs[x]]+1;&#125; inline int new_node(int x) &#123; sz[++cnt]=1,ls[cnt]=rs[cnt]=0,fix[cnt]=rand(),val[cnt]=x; return cnt; &#125; inline int merge(int x,int y) &#123; if (!x||!y) return x+y; if (fix[x]&lt;fix[y]) &#123;rs[x]=merge(rs[x],y),pushup(x);return x;&#125; else &#123;ls[y]=merge(x,ls[y]),pushup(y);return y;&#125; &#125; inline void split(int pos,int k,int &amp;x,int &amp;y) &#123; if (!pos) return x=y=0,void(); if (sz[ls[pos]]&gt;=k) y=pos,split(ls[pos],k,x,ls[y]),pushup(y); else x=pos,split(rs[pos],k-sz[ls[pos]]-1,rs[x],y),pushup(x); &#125; inline int find(int k) &#123; int now=rt; while(1)&#123; if (sz[ls[now]]&gt;=k) now=ls[now]; else if (sz[ls[now]]+1==k) return now; else k=k-sz[ls[now]]-1,now=rs[now]; &#125; &#125; inline void update(int t,int v) &#123; int x=find(t+1); val[x]=v; &#125; inline void insert(int t,int v) &#123; int x,y,z; split(rt,t,x,y); rt=merge(x,merge(new_node(v),y)); &#125; inline int query(int t) &#123; int x=find(t); return val[x]; &#125;&#125;int n,m;int q[maxn],p[maxn],H[maxn&lt;&lt;1],a[maxn];int w[maxn],sta[maxn],top;inline int find(int x,int y)&#123; return (q[x]-q[y])/(p[y]-p[x]);&#125;inline int push(int x)&#123; while(find(x,sta[top])&gt;=w[top]&amp;&amp;top) top--; if (top==0) sta[++top]=x,w[top]=maxval; else sta[++top]=x,w[top]=find(x,sta[top-1]);&#125;inline int Pos(int x)&#123; int l=1,r=top,ans; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if (x&lt;=w[mid]) l=mid+1,ans=mid; else r=mid-1; &#125; return sta[ans];&#125;int main()&#123; n=rd(),m=rd(); char s[10]; rep(i,1,m)&#123; scanf("%s",s+1); if (s[1]=='I')&#123; int x=rd(),val=rd(); Treap::insert(x,val); &#125; else &#123; int x=rd(),val=rd(); Treap::update(x,val); &#125; &#125; rep(i,1,n) p[i]=-rd(),q[i]=rd(),a[i]=Treap::query(i); int tot=0; rep(i,1,n) &#123; H[++tot]=a[i]; if (i&gt;1) H[++tot]=find(i,i-1); &#125; sort(H+1,H+1+tot); push(1); rep(i,2,n)&#123; int w=Pos(a[i]); ll Ans=1ll*p[w]*a[i]+(ll)q[w]; //wrt(w,' '); //rep(j,1,i-1) printf("%d %d %lld\n",i,j,(ll)p[j]*a[i]+q[j]); wrt(max(Ans,0ll),'\n'); push(i); &#125;&#125; 数学打表可知 $Ans=n×m×\varphi(n)×\varphi(m)$ 直接使用 $\varphi(n)=n\prod\limits \frac{p_k-1}{p_k}$ $p_k$是$n$的因子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/11*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 40000005#define mod 998244353int pri[maxn],tp;bool vis[maxn];inline void euler(int mx)&#123; rep(i,2,mx)&#123; if (!vis[i]) pri[++tp]=i; for(int j=1;pri[j]*i&lt;=mx;j++)&#123; vis[i*pri[j]]=1; if (i%pri[j]==0) break; &#125; &#125;&#125;ll num[1000005];inline ll phi(ll x)&#123; ll ans=x,X=x; int tot=0; for(int i=1;i&lt;=tp&amp;&amp;pri[i]&lt;=x;i++)if (x%pri[i]==0)&#123; num[++tot]=pri[i]; x/=pri[i]; while(x%pri[i]==0) x/=pri[i]; &#125; if (x&gt;1) num[++tot]=x; rep(i,1,tot) ans=ans/num[i]; rep(i,1,tot) ans=ans*(num[i]-1); return ans;&#125;int main()&#123; euler(3222776); ll n=rd(),m=rd(); wrt((n%mod)*(m%mod)%mod*(phi(n)%mod)%mod*(phi(m)%mod)%mod,'\n');&#125; tty 的求助公式考场上没推出来QwQ，公式推导参考这里 然后我的计算方法不是数论分块，可以直接暴力计算，复杂度是调和级数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/11*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 5000005#define mod 998244353int mu[maxn],pri[maxn],tp;bool vis[maxn];inline void euler(int mx)&#123; mu[1]=1; rep(i,2,mx)&#123; if (!vis[i]) pri[++tp]=i,mu[i]=-1; for(int j=1;j&lt;=tp&amp;&amp;pri[j]*i&lt;=mx;j++)&#123; vis[i*pri[j]]=1; if (i%pri[j]==0)&#123; mu[i*pri[j]]=0; break; &#125; else mu[i*pri[j]]=mu[i]*(-1); &#125; &#125;&#125;inline ll solve(int N,int M,int x)&#123; int mx1=min(N,M); euler(mx1); ll ans=0; rep(d,1,mx1)&#123; int mx2=min(N/d,M/d); ll res=0; rep(t,1,mx2) res+=mu[t]*(N/(1ll*t*d))*(M/(1ll*t*d)), res=res%mod; ans=(ans+(2ll*d*(x/d)%mod+d)%mod*res)%mod; &#125; return ans;&#125;#define inv2 499122177inline ll S(int x)&#123; return 1ll*x*(x+1)%mod*inv2%mod;&#125;int main()&#123; int N=rd(),M=rd(),x=rd(); ll ans=solve(N,M,x); ans=ans+S(N)*S(M)%mod; ans=ans-S(M)*N%mod; ans=ans-S(N)*M%mod; ans=ans%mod; ans=ans&lt;0?ans+mod:ans; ans=ans*inv2%mod; wrt(ans,'\n');&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[contest0110]]></title>
    <url>%2F2019%2F01%2F10%2Fcontest0110%2F</url>
    <content type="text"><![CDATA[模拟赛 题目链接放原题的吧 marshland网络流 将图分为三类点，$X+Y$为奇数的$A$点和$X+Y$为偶数的$B$点。 在将$B$点分为$X$为奇数的$B’$点和$X$为偶数的$B’’$点 可以强制最后答案$L$型的初始端点为$B’$点，这样就可以方便的建图了 $S \rightarrow B’ \rightarrow A \rightarrow B’’ \rightarrow T$ 要建立一个$S’$点来满足$m$的限制。 $S’$向$S$要连一条容量为$1$，费用为$0$的边，然后再残留网络上跑一遍费用流，进行$m$次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/10*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];~x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 300005ll nx[maxn],to[maxn],hd[maxn],val[maxn],cost[maxn],cnt=-1;inline void add(int u,int v,int c,ll L) &#123; //wrt(u,' '),wrt(v,' '),wrt(c,'\n'); nx[++cnt]=hd[u],to[cnt]=v,cost[cnt]=-c,val[cnt]=L,hd[u]=cnt; nx[++cnt]=hd[v],to[cnt]=u,cost[cnt]=c,val[cnt]=0,hd[v]=cnt; &#125;int n,m,p,num;ll a[55][55],s,t,s1;bool vis[55][55];ll pre1[maxn],pre2[maxn],dis[maxn];ll ans=0;bool inq[maxn];queue&lt;int&gt; que;inline int get(int x,int y)&#123;return (x-1)*n+y;&#125;#define INF 16666666666ll min_cost_flow()&#123; ll flow=0,f=INF; while(f &gt; 0)&#123; memset(inq, 0, sizeof(inq)); rep(i,1,t) dis[i]=INF; dis[s]=0,que.push(s); while(!que.empty())&#123; int u=que.front();que.pop(); inq[u]=0; cross(x,u)&#123; if(val[x]&gt;0 &amp;&amp; dis[to[x]] &gt; dis[u] + cost[x])&#123; dis[to[x]]=dis[u]+cost[x]; pre1[to[x]]=u,pre2[to[x]]=x; if(!inq[to[x]]) que.push(to[x]),inq[to[x]]=1; &#125; &#125; &#125; //wrt(dis[t],'\n'); if(dis[t]==INF) return ans; ll delta=f; for(int i=t;i!=s;i=pre1[i]) delta=min(delta,val[pre2[i]]); f-=delta,flow+=delta,ans+=delta*dis[t]; for(int i=t;i!=s;i=pre1[i]) val[pre2[i]]-=delta,val[pre2[i]^1]+=delta; &#125;&#125;int main()&#123; memset(hd,-1,sizeof hd); n=rd(),m=rd(),p=rd(),num=n*n; ll sum=0; s=num*2+1,s1=num*2+2,t=num*2+3; rep(i,1,n) rep(j,1,n) a[i][j]=rd(),sum+=a[i][j]; rep(i,1,p)&#123; int x=rd(),y=rd(); vis[x][y]=1; &#125; rep(i,1,n) rep(j,1,n) if (!vis[i][j]) add(get(i,j),get(i,j)+num,a[i][j],1); for(int i=1;i&lt;=n;i+=2)&#123; for(int j=1;j&lt;=n;j+=2)&#123; int out=get(i,j)+num; if (j&gt;1) add(out,get(i,j-1),0,INF); if (j&lt;n) add(out,get(i,j+1),0,INF); if (i&gt;1) add(out,get(i-1,j),0,INF); if (i&lt;n) add(out,get(i+1,j),0,INF); &#125; &#125; for(int i=1;i&lt;=n;i+=2)&#123; for(int j=2;j&lt;=n;j+=2)&#123; int out=get(i,j)+num; if (i&gt;1) add(out,get(i-1,j),0,INF); if (i&lt;n) add(out,get(i+1,j),0,INF); &#125; &#125; for(int i=2;i&lt;=n;i+=2)&#123; for(int j=1;j&lt;=n;j+=2)&#123; int out=get(i,j)+num; if (j&gt;1) add(out,get(i,j-1),0,INF); if (j&lt;n) add(out,get(i,j+1),0,INF); &#125; &#125; for(int i=2;i&lt;=n;i+=2) for(int j=2;j&lt;=n;j+=2) add(get(i,j)+num,t,0,INF); for(int i=1;i&lt;=n;i+=2) for(int j=1;j&lt;=n;j+=2) add(s1,get(i,j),0,INF); ll x=0; rep(i,1,m)&#123; add(s,s1,0,1); x=min(x,min_cost_flow()); &#125; wrt(sum+x,'\n');&#125; party最终一定在所有点$Lca$处集合，答案一定是$c$的倍数 可以找出路径上所有出现过的颜色，然后二分答案，二分图匹配，这样可得$45pt$ 用$bitset$，树剖维护，维护每个点跳到$top_x$的$bitset$或和 这里需要一点技巧，要强制每条重链长度不超过$\sqrt n$ 然后使用hall定理 $2^n​$枚举子集，所有子集中答案除以子集大小取$min​$ 然后$min*c$就是最终答案 时间复杂度$O(\sqrt n\frac{m}{64}q+mq)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/10*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 400005int nx[maxn],to[maxn],hd[maxn],cnt;inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125;int a[maxn];int top[maxn],fa[maxn],dep[maxn],sz[maxn],son[maxn];int sn,n,m,c,q;inline void dfs(int u)&#123; dep[u]=dep[fa[u]]+1,sz[u]=1; cross(i,u)&#123; fa[to[i]]=u,dfs(to[i]),sz[u]+=sz[to[i]]; if (sz[to[i]]&gt;sz[son[u]]) son[u]=to[i]; &#125;&#125;bitset&lt;1005&gt; jump[maxn];bitset&lt;1005&gt; A[6],now,tmp[6];int Q[maxn];inline void dfs(int u,int tp)&#123; if (dep[u]-dep[tp]&gt;sn) tp=u; if (tp!=u) jump[u]=jump[fa[u]],jump[u][a[u]]=1; else jump[u][a[u]]=1; top[u]=tp; if (son[u]) dfs(son[u],tp); cross(i,u) if (to[i]!=son[u]) dfs(to[i],to[i]);&#125;inline int _lca(int u,int v)&#123; while(top[u]!=top[v]) if (dep[top[u]]&gt;dep[top[v]]) u=fa[top[u]]; else v=fa[top[v]]; return dep[u]&lt;dep[v]?u:v;&#125;inline void Get(int u,int v,int res)&#123; A[res].reset(); while(top[u]!=top[v]) A[res]|=jump[u],u=fa[top[u]]; while(u!=v) A[res][a[u]]=1,u=fa[u]; A[res][a[v]]=1;&#125;int Ans;inline void work(int k,int use)&#123; if (k&gt;c)&#123; if (use) Ans=min(Ans,(int)now.count()/use); return ; &#125; work(k+1,use); tmp[k]=now,now=now|A[k]; work(k+1,use+1); now=tmp[k];&#125;void solve()&#123; int Lca=Q[1]; rep(i,2,c) Lca=_lca(Lca,Q[i]); rep(i,1,c) Get(Q[i],Lca,i); Ans=n,work(1,0); wrt(Ans*c,'\n');&#125;int main()&#123; n=rd(),m=rd(),q=rd(); rep(i,2,n) add(rd(),i); rep(i,1,n) a[i]=rd(); sn=sqrt(n); dfs(1),dfs(1,1); rep(i,1,q)&#123; c=rd(); rep(i,1,c) Q[i]=rd(); solve(); &#125;&#125; platform$idea\ by\ sooke$ 后缀数组 可以发现对于每一个后缀，排名递减，权值递增，所以最多只会有一个交点。 二分交点，权值可以前缀和维护。 对于一个串的排名，此处排名是升序，最后总数相减即可。 最后本质不同的子串数为$\frac{n*(n+1)}{2}-\sum\limits_{i=1}^nheight[i]$ 从前往后扫，对于一个后缀$x$，$1到height[x]$的位置排名都将继承前一个后缀的前$height[x]$个数的排名 第$height[x]+1$到最后一个位置的排名一定是前面的最大值后连续的数。 使用栈维护栈内每个元素$x$记录它的排名是$l_x到r_x$，然后二分即可。 时间复杂度$O(nlogn)$，跑到飞快 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/10*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 100005int tp[maxn],tax[30],a[maxn],n,m;int rk[maxn],height[maxn],sa[maxn];int cmp(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;inline void Qsort() &#123; rep(i,0,m) tax[i]=0; rep(i,1,n) tax[rk[i]]++; rep(i,1,m) tax[i]+=tax[i-1]; drp(i,n,1) sa[ tax[rk[tp[i]]]-- ]=tp[i];&#125;void SAsort() &#123; rep(i,1,n) rk[i]=a[i],tp[i]=i; Qsort(); for(int w=1,p=0;p&lt;n;m=p,w&lt;&lt;=1) &#123; p=0; rep(i,1,w) tp[++p]=n-w+i; rep(i,1,n) if (sa[i]&gt;w) tp[++p]=sa[i]-w; Qsort(),swap(tp,rk); rk[sa[1]]=p=1; rep(i,2,n) rk[sa[i]]=cmp(tp,sa[i-1],sa[i],w)?p:++p; &#125;&#125;void calheight(int *r,int *sa,int n) &#123; int i,j,k=0; for(i=1;i&lt;=n;height[rk[i++]]=k)&#123; if (!rk[i]) continue; for(k?k--:0,j=sa[rk[i]-1];r[i+k]==r[j+k];) k++; &#125; return;&#125;char s[maxn];struct node &#123; ll l,r,S; bool operator &lt; (const node &amp;B)const&#123;return S&lt;B.S;&#125;&#125;sta[maxn];int top,Ans;ll tot;pair&lt;int,int&gt; res[maxn];int sum[maxn];ll mx;inline void getans(int bg,int R) &#123; int l=1,r=R; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; int pos=lower_bound(sta+1,sta+1+top,node&#123;0,0,mid&#125;)-sta; ll rk=mx-(sta[pos].l+(mid-sta[pos-1].S-1))+1; ll S=sum[bg+mid-1]-sum[bg-1]; if (rk==S) &#123; res[++Ans]=make_pair(bg,bg+mid-1); return ; &#125; if (rk&lt;S) r=mid-1; else l=mid+1; &#125;&#125;inline void push(int x) &#123; if (height[x]==0) top=0; else &#123; int pos=lower_bound(sta+1,sta+1+top,node&#123;0,0,height[x]&#125;)-sta; sta[pos].r=(sta[pos].l+(height[x]-sta[pos-1].S-1)); sta[pos].S=sta[pos-1].S+(sta[pos].r-sta[pos].l+1); top=pos; &#125; sta[++top]=node&#123;tot+1,tot+(n-sa[x]+1)-height[x],0&#125;; tot=sta[top].r; sta[top].S=sta[top-1].S+sta[top].r-sta[top].l+1;&#125;int main()&#123; //n=rd(); scanf("%s",s+1); n=strlen(s+1);m=27; rep(i,1,n) a[i]=s[i]-'a'+1; SAsort(); calheight(a,sa,n); mx=1ll*n*(n+1)/2; rep(i,1,n) sum[i]=sum[i-1]+rd(),mx-=height[i]; rep(i,1,n) push(i),getans(sa[i],n-sa[i]+1); sort(res+1,res+1+Ans); wrt(Ans,'\n'); rep(i,1,Ans) wrt(res[i].first,' '),wrt(res[i].second,'\n');&#125;]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式]]></title>
    <url>%2F2019%2F01%2F09%2FPolynomial%2F</url>
    <content type="text"><![CDATA[这里是一些模板然而并不会写教程 蝴蝶操作123456789int r[maxn], l, lim;inline void init(int len, int type = 1) &#123; if (type) &#123; lim = 1, l = 0; while (lim &lt;= len) lim &lt;&lt;= 1, l++; &#125; else lim = 1 &lt;&lt; len, l = len; rep(i, 0, lim - 1) r[i] = ((r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)));&#125; $FFT$1234567891011121314151617181920212223242526272829const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125; complex operator + (const complex &amp;B) &#123;return complex(x+B.x,y+B.y);&#125; complex operator - (const complex &amp;B) &#123;return complex(x-B.x,y-B.y);&#125; complex operator * (const complex &amp;B) &#123;return complex(x*B.x-y*B.y,B.x*y+x*B.y);&#125;&#125;a[maxn],b[maxn];int n,m,r[maxn],l,lim;void FFT(complex *A,int type)&#123; rep(i,0,lim-1) if (i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1)&#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for(int R=mid&lt;&lt;1,j=0;j&lt;lim;j+=R)&#123; complex w(1,0); for(int k=0;k&lt;mid;k++,w=w*Wn)&#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k]=x+y; A[j+mid+k]=x-y; &#125; &#125; &#125;&#125; $NTT$123456789101112131415161718192021222324252627inline int qpow(int x,int k)&#123; int ans=1; for(;k;x=1ll*x*x%mod,k&gt;&gt;=1) if (k&amp;1) ans=1ll*ans*x%mod; return ans;&#125;inline int Mod(int x)&#123;return x&lt;0?x+mod:(x&gt;=mod?x-mod:x);&#125;int lim,r[100005],l;void NTT(int *a,int type)&#123; rep(i,0,lim-1) if (i&lt;r[i]) swap(a[i],a[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1)&#123; int Wn=qpow(g,(mod-1)/(mid&lt;&lt;1)); if (type==-1) Wn=qpow(Wn,mod-2); for(int R=mid&lt;&lt;1,j=0;j&lt;lim;j+=R)&#123; for(int k=0,w=1;k&lt;mid;k++,w=1ll*w*Wn%mod)&#123; int x=a[j+k],y=1ll*w*a[j+k+mid]%mod; a[j+k]=Mod(x+y); a[j+k+mid]=Mod(x-y); &#125; &#125; &#125; if (type==-1)&#123; int x=qpow(lim,mod-2); rep(i,0,lim-1) a[i]=1ll*a[i]*x%mod; &#125;&#125; 分治NTT123456789101112131415161718192021222324void mul(int *a,int *b)&#123; NTT(a,1),NTT(b,1); rep(i,0,lim-1) a[i]=1ll*a[i]*b[i]%mod; NTT(a,-1);&#125;inline void init(int n)&#123; lim=1,l=0; while(lim&lt;=n)lim=lim&lt;&lt;1,++l; rep(i,0,lim-1) r[i]=((r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1))),A[i]=B[i]=0;&#125;void cdqNTT(int l,int r)&#123; if (l==r) return ; int mid=(l+r)&gt;&gt;1; cdqNTT(l,mid); init(r-l+1); rep(i,l,mid) A[i-l]=a[i]; rep(i,0,r-l) B[i]=b[i]; mul(A,B); rep(i,mid+1,r) a[i]-=A[i-l],a[i]=a[i]&lt;0?a[i]+mod:a[i]; cdqNTT(mid+1,r);&#125; 多项式求逆$$n==1:\f(x) \equiv c (mod\ x)\ \ \ \ \ \ c为常数\f^{-1} \equiv c^{-1} (mod\ x)\n&gt;1:\f(x)g(x) \equiv 1 (mod\ x^n)\设f(x)g’(x) \equiv 1 (mod\ x^{\lceil\frac{n}{2}\rceil})\f(x)g(x) \equiv 1 (mod\ x^{\lceil\frac{n}{2}\rceil})\以上两式相减\g(x)-g’(x) \equiv 0 (mod\ x^{\lceil\frac{n}{2}\rceil})\两边平方\g^2(x)-2g’(x)g(x)+g’^2(x)\equiv 0(mod\ x^n)\同乘f(x)\g(x)\equiv 2g’(x)-f(x)g’^2(x)(mod x^n)\时间复杂度:T(n)=T(\frac{n}{2})+O(n log n)=O(n log n)$$ 12345678910111213141516void solve(int n)&#123; if (n==1)&#123; G[0]=qpow(F[0],mod-2); return ; &#125; solve((n+1)&gt;&gt;1); init(n*2); rep(i,0,n-1) A[i]=F[i]; rep(i,n,lim-1) A[i]=0; NTT(A,1),NTT(G,1); rep(i,0,lim-1) G[i]=1ll*Mod(2-1ll*A[i]*G[i]%mod)*G[i]%mod; NTT(G,-1); rep(i,n,lim-1) G[i]=0;&#125; $MTT$此坑待填]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF487E]]></title>
    <url>%2F2019%2F01%2F09%2FCF487E%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2019%2F01%2F09%2Fbzoj2125%2F</url>
    <content type="text"><![CDATA[圆方树 题目链接 建出圆方树，圆点到方点的距离为它爬到这个方点在圆方树的父亲的距离，圆点到圆点之间的距离为边长。 两个点的最短路长度分两种情况讨论： $Lca$为圆点，那么就是树上距离 $Lca$为方点，那两个点就都爬到这个方点对应的环上，再求一个环上距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/09*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;map&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 500005#define maxm 500005int tot,n,m,a[maxn],Q;#define len(x,y) (mp[make_pair(x,y)])map&lt; pair&lt;int,int&gt;,int &gt; mp;namespace Tree &#123; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn&lt;&lt;1],cnt; inline void add(int u,int v) &#123; //wrt(u,' '),wrt(v,'\n'); nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt; &#125; ll sum1[maxn&lt;&lt;1],sum2[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],Dep[maxn&lt;&lt;1]; int f[maxn&lt;&lt;1][20],dep[maxn&lt;&lt;1]; void dfs(int u) &#123; dep[u]=dep[f[u][0]]+1,Dep[u]=Dep[f[u][0]]+sum[u]; //wrt(u,' '),wrt(sum[u],' '),wrt(Dep[u],'\n'); rep(i,1,16) f[u][i]=f[f[u][i-1]][i-1]; cross(i,u) f[to[i]][0]=u,dfs(to[i]); &#125; inline int _lca(int u,int v) &#123; if (dep[u]&lt;dep[v]) swap(u,v); drp(i,16,0) if (dep[f[u][i]]&gt;=dep[v]) u=f[u][i]; if (u==v) return u; drp(i,16,0) if (f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; return f[u][0]; &#125; inline int jump(int u,int v) &#123; drp(i,16,0) if (dep[f[u][i]]&gt;dep[v]) u=f[u][i]; return u; &#125; inline ll dis(int x,int y) &#123; int Lca=_lca(x,y); if (Lca&lt;=n) return (Dep[x]+Dep[y]-2*Dep[Lca]); else &#123; int xx=jump(x,Lca),yy=jump(y,Lca); if (sum1[xx]&lt;sum1[yy]) swap(xx,yy); return Dep[x]-Dep[xx]+Dep[y]-Dep[yy]+ min(sum1[xx]-sum1[yy],sum2[xx]+sum1[yy]); &#125; &#125;&#125;int dfn[maxn],low[maxn],id;int sta[maxn],top; int nx[maxm],to[maxm],val[maxm],hd[maxn],cnt;int ans;inline void add(int u,int v,int L) &#123; nx[++cnt]=hd[u],val[cnt]=L,to[cnt]=v,hd[u]=cnt;&#125;void tarjan(int u,int fa) &#123; dfn[u]=low[u]=++id; sta[++top]=u; for(int i=hd[u];i;i=nx[i]) if (to[i]!=fa) &#123; int v=to[i]; if (!dfn[v]) &#123; tarjan(v,u); low[u]=min(low[u],low[v]); if (low[v]&gt;dfn[u]) &#123; Tree::add(u,v),top--; Tree::sum[v]=val[i]; &#125; else if (low[v]==dfn[u]) &#123; tot++; int x=top; while(sta[x]!=v) Tree::add(n+tot,sta[x]),x--; Tree::add(n+tot,sta[x]); Tree::add(u,n+tot); Tree::sum1[sta[x]]=val[i]; rep(j,x+1,top) Tree::sum1[sta[j]]= Tree::sum1[sta[j-1]]+len(sta[j-1],sta[j]); Tree::sum2[sta[top]]=len(sta[top],u); Tree::sum[sta[top]]= min(Tree::sum1[sta[top]],Tree::sum2[sta[top]]); drp(j,top-1,x)&#123; Tree::sum2[sta[j]]= Tree::sum2[sta[j+1]]+len(sta[j+1],sta[j]); Tree::sum[sta[j]]= min(Tree::sum1[sta[j]],Tree::sum2[sta[j]]); &#125; top=x-1; &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125;int main()&#123; freopen("test.in","r",stdin); freopen("test.out","w",stdout); n=rd(),m=rd();Q=rd(); rep(i,1,m) &#123; int x=rd(),y=rd(),z=rd(); add(x,y,z),add(y,x,z); len(x,y)=len(y,x)=z; &#125; tarjan(1,0);Tree::dfs(1); rep(i,1,Q)&#123; int x=rd(),y=rd(); wrt(Tree::dis(x,y),'\n'); &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小C的独立集]]></title>
    <url>%2F2019%2F01%2F09%2Fbzoj4316%2F</url>
    <content type="text"><![CDATA[圆方树入门 题目链接 建出圆方树，圆点和圆点之间按正常转移，遇到圆点和方点时，把整个环拉出来，单独跑一遍$DP$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/09*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 500005#define maxm 500005int tot,n,m,a[maxn];namespace Tree&#123; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn&lt;&lt;1],cnt; inline void add(int u,int v) &#123; //wrt(u,' '),wrt(v,'\n'); nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt; &#125; int mx; int dp[maxn][2]; int Dp[maxn][2]; inline void DP(int A,int B,vector &lt; pair&lt;int,int&gt; &gt; x) &#123; Dp[0][0]=A,Dp[0][1]=B; rep(i,1,x.size()-1)&#123; Dp[i][0]=max(Dp[i-1][0],Dp[i-1][1])+x[i].second; Dp[i][1]=Dp[i-1][0]+x[i].first; &#125; &#125; void dfs(int u,int fa) &#123; cross(i,u)if (to[i]!=fa)&#123; int v=to[i]; if (v&gt;n) &#123; pair&lt;int,int&gt; ans; vector&lt; pair&lt;int,int&gt; &gt; vt; int tt=0; cross(j,v) &#123; dfs(to[j],v); vt.push_back(make_pair(dp[to[j]][1],dp[to[j]][0])); &#125; int xx=vt[0].first,yy=vt[0].second; tt=vt.size()-1; DP(yy,xx,vt),dp[u][0]+=max(Dp[tt][0],Dp[tt][1]); DP(yy,-2333333,vt),dp[u][1]+=Dp[tt][0]; &#125; else &#123; dp[u][0]+=max(dp[v][0],dp[v][1]); dp[u][1]+=dp[v][0]; &#125; &#125; dp[u][1]++; &#125; int calc(int u) &#123; dfs(u,0); return max(dp[u][0],dp[u][1]); &#125;&#125;int dfn[maxn],low[maxn],id;int sta[maxn],top; int nx[maxm],to[maxm],hd[maxn],cnt;int ans;inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125;void tarjan(int u,int fa) &#123; Tree::mx++; dfn[u]=low[u]=++id; sta[++top]=u; for(int i=hd[u];i;i=nx[i]) if (to[i]!=fa) &#123; int v=to[i]; if (!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); if (low[v]==dfn[u]) &#123; //对于一般图，此处为&gt;=；对于仙人掌，此处为== tot++; while(sta[top]!=v) Tree::add(n+tot,sta[top--]); Tree::add(n+tot,sta[top--]); Tree::add(u,n+tot); &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125;void init(int n)&#123; rep(i,1,n) if (!dfn[i]) &#123; Tree::mx=0; tarjan(i,0),ans+=Tree::calc(i); &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int x=rd(),y=rd(); add(x,y),add(y,x); &#125; init(n); wrt(ans,'\n');&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铁人两项]]></title>
    <url>%2F2019%2F01%2F09%2Fluogu-4630%2F</url>
    <content type="text"><![CDATA[圆方树入门 题目链接 转化一下题意，等价于求$\sum\limits_x\sum\limits_y S_{x,y}$ $S_{x,y}$表示$x$到$y$的所有不经过重复点的路径可能经过的点的个数 建出圆方树，方点权值为点双大小，圆点权值为$-1$，问题就变成了求树上所有圆点对的路径长度之和 路径长度定义为树上两点路径经过点的权值和（包含这两点）。 每个点的贡献就是经过它的路径数$×$它的权值 注意：图不一定联通 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 600005#define maxm 600005int tot,n,m;namespace Tree&#123; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125; int g[maxn&lt;&lt;1],mx; ll ans; int dfs(int u,int fa) &#123; int sum=u&lt;=n; cross(i,u) if (to[i]!=fa) &#123; int x=dfs(to[i],u); ans+=2ll*g[u]*x*sum; sum+=x; &#125; ans+=2ll*g[u]*sum*(mx-sum); return sum; &#125;&#125;int dfn[maxn],low[maxn],id;int sta[maxn],top; int nx[maxm],to[maxm],hd[maxn],cnt;inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125;void tarjan(int u,int fa) &#123; Tree::mx++; dfn[u]=low[u]=++id; sta[++top]=u; for(int i=hd[u];i;i=nx[i]) if (to[i]!=fa) &#123; int v=to[i]; if (!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); if (low[v]&gt;=dfn[u]) &#123; //对于一般图，此处为&gt;=；对于仙人掌，此处为== tot++;Tree::g[n+tot]=2; while(sta[top]!=v) Tree::g[n+tot]++,Tree::add(n+tot,sta[top--]); Tree::add(n+tot,sta[top--]); Tree::add(u,n+tot); &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125;void init(int n)&#123; rep(i,1,n) Tree::g[i]=-1; rep(i,1,n) if (!dfn[i]) &#123; Tree::mx=0; tarjan(i,0),Tree::dfs(i,0); &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int x=rd(),y=rd(); add(x,y),add(y,x); &#125; init(n); wrt(Tree::ans,'\n');&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆方树]]></title>
    <url>%2F2019%2F01%2F08%2Fyuanfangshu%2F</url>
    <content type="text"><![CDATA[出题人把序列上的题加个树剖放到树上是错误的应该加个圆方树放到仙人掌上 圆方树题的整理和一个模板 圆方树初学的话点这里 然后放个建树模板 12345678910111213141516171819202122void tarjan(int u,int fa) &#123; Tree::mx++; dfn[u]=low[u]=++id; sta[++top]=u; for(int i=hd[u];i;i=nx[i]) if (to[i]!=fa) &#123; int v=to[i]; if (!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); //if (low[v]&gt;dfn[u]) Tree::add(u,v);else //仙人掌时加上句 if (low[v]&gt;=dfn[u]) &#123; //对于一般图，此处为&gt;=；对于仙人掌，此处为== tot++; while(sta[top]!=v) Tree::add(n+tot,sta[top--]); Tree::add(n+tot,sta[top--]); Tree::add(u,n+tot); &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125; problems铁人两项 小C的独立集 最短路 tourists]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小清新数据结构题]]></title>
    <url>%2F2019%2F01%2F06%2Fluogu-3676%2F</url>
    <content type="text"><![CDATA[真是小清新 题目链接 题意查询以$x$为根时的所有子树的权值和的平方和，带单点修改、 做法为了表达方便，记$q$为询问的点，我们用$x$表示$1$到$q$路径上的点 可以先$O(n)$的处理出以$1$为根时：​ 答案，记为$Ans$ ​ 每颗子树的权值和，记为$S_i$ ​ 所有点权值和，记为$Sum$ ​ 点的深度，记为$dep_i$，$dep_1=1$ 考虑修改修改点$q$，记原来值和当前值差为$d$ $Sum=Sum+dep_x*d$ $Ans=Ans-\sum\limits_x(S_x)^2+\sum\limits_x(S_x+d)^2$ $=Ans-\sum\limits_x(S_x)^2+\sum\limits_x(S_x)^2+2S_xd+d^2$ $=Ans+\sum\limits_{x}2S_xd+d^2$ $=Ans+2 d\sum\limits_x S_x+dep_x d^2$ 所有$S_x=S_x+d$ 当根换为$q$时此时点$x$，不含点$q$，$S_x$会变为$Sum-S_{son}$，$S_{son}$表示$x$的包含点$q$的子树的大小 其余点不变 所以答案为 $Ans-\sum\limits_x(S_x)^2+Sum^2+\sum\limits_x(Sum-S_x)^2$ $=Ans+\sum\limits_x(Sum-S_x)^2-(S_x)^2+Sum^2$ 平方差公式展开 $=Ans+Sum^2+\sum\limits Sum(Sum-2S_x)$ $=Ans+Sum^2+Sum\sum\limits Sum-2S_x$ $=Ans+Sum^2+Sum^2dep_x+2Sum\sum\limits S_x$ 用树剖+树状数组维护链上加，链上求和就好了 代码时间复杂度$O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/04*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 200005namespace Tree_Array&#123; ll sum[maxn],Sum[maxn]; int n; inline void add(int x,int val) &#123; for(int i=x;i&lt;=n;i+=i&amp;(-i)) sum[i]+=val,Sum[i]+=1ll*x*val; &#125; inline ll getsum(int x) &#123; ll ans=0; for(int i=x;i;i-=i&amp;(-i)) ans+=(x+1)*sum[i]-Sum[i]; return ans; &#125; inline void update(int l,int r,int x) &#123;add(l,x),add(r+1,-x);&#125; inline ll query(int l,int r)&#123;return getsum(r)-getsum(l-1);&#125;&#125;namespace Tree&#123; int n; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn],cnt; inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125; int top[maxn],sz[maxn],fa[maxn],son[maxn],dep[maxn]; int val[maxn],a[maxn]; int sum[maxn]; ll Ans,S; int idx[maxn],id; void dfs(int u) &#123; dep[u]=dep[fa[u]]+1,sz[u]=1;sum[u]=a[u]; cross(i,u) if (to[i]!=fa[u])&#123; fa[to[i]]=u,dfs(to[i]); sz[u]+=sz[to[i]],sum[u]+=sum[to[i]]; if (sz[son[u]]&lt;sz[to[i]]) son[u]=to[i]; &#125; &#125; void dfs(int u,int tp) &#123; idx[u]=++id;val[id]=a[u]; top[u]=tp; if (son[u]) dfs(son[u],tp); cross(i,u) if (to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs(to[i],to[i]); &#125; inline void init() &#123; dfs(1),dfs(1,1); Tree_Array::n=id; rep(i,1,id) Tree_Array::update(idx[i],idx[i],sum[i]),Ans+=sum[i]*sum[i]; S=sum[1]; &#125; inline void link_update(int x,ll val) &#123; while(1)&#123; Tree_Array::update(idx[top[x]],idx[x],val); if (top[x]==1) return ; x=fa[top[x]]; &#125; &#125; inline ll sigma(int x) &#123; ll ans=0; while(1)&#123; ans+=Tree_Array::query(idx[top[x]],idx[x]); if (top[x]==1) return ans; x=fa[top[x]]; &#125; &#125; inline ll query(int x) &#123;return Ans+S*S+1ll*dep[x]*S*S-2ll*S*sigma(x);&#125; inline void update(int x,ll val) &#123; ll delta=val-a[x],s1=sigma(x),s2=dep[x]; Ans+=2*s1*delta+delta*delta*dep[x]; S+=delta; link_update(x,delta); a[x]=val; &#125;&#125;using namespace Tree;int main()&#123; n=rd(); int m=rd(); rep(i,1,n-1) &#123; int x=rd(),y=rd(); add(x,y);add(y,x); &#125; rep(i,1,n) a[i]=rd(); init(); rep(_i,1,m)&#123; int op=rd(); if (op==1)&#123; int x=rd(),val=rd(); update(x,val); &#125; else &#123; int x=rd(); wrt(query(x),'\n'); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大森林]]></title>
    <url>%2F2018%2F12%2F13%2Fbzoj4573%2F</url>
    <content type="text"><![CDATA[有趣的LCT题 题目链接 写在前面的一些结论： 合法的$2$操作只会在一段连续的区间内发生，所以合法$2$操作也只会在一段区间内发生，因此我们可以把更换生长节点的区间，和加点区间取并，使$2$操作一定合法 如果$2$操作一定合法，加点操作区间从l~r变为1~n并不影响答案 一个询问在该询问进入时处理，和之后处理，答案并不改变，并且只有涉及到该树的操作才会对这个询问产生影响 结论是显然的 知道这些之后，来考虑如何解决； 一个想法可以基于上面结论，产生一个愚蠢的想法 设$x$为$2$操作后的生长节点，$y$为之前的 将$2$操作拆成两次： 在$l$处，将之后加入所有点，换到$x$下面 在$r+1$处,将之后加入所有点，换回$y$下面 然后将询问和$2$操作按位置排序，从1~n扫一遍，依次处理就得到了$O(n^{2})$的优秀做法 那么如何优化虚点!!!对每一个$2$操作建一个虚点，每个虚点的父节点是前一个虚点，第一个虚点的父亲是1 每一次加点就加到当前最后一个虚点下面就好了。 每次移动就直接将该$2$操作对应的虚点及其子树移到新的生长节点下然而还是T 统计答案我们让虚点权值为0，实点为1 设一个点i到根路径上权值和为 $S_{i}$(包含自身权值) $dis(u,v)=S_{u}+S_{v}-2S_{lca}$ 大家举几个栗子，想象一下，就知道这是对的。我不会证 LCT大法吼！！！移动子树相当于换父亲，LCT就可以了。 但是此处LCT 不能换根，因为有虚点，不同于普通树上路径，所以根的位置对答案会产生影响。 此处cut操作一定是儿子cut父亲，所以直接cut掉就可以了，like this1access(u);splay(u);fa[son[u][0]]=0,son[u][0]=0; 而link操作也一定是一颗树的根去link，所以也直接link就好了，像这样1access(v),splay(v),fa[v]=u; 然后就愉快的A了此题，时间复杂度$O(nlogn)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/* Author: zxy_hhhh date: 2018/12/07*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longinline ll rd() &#123; ll _x = 0; int _ch = getchar(), _f = 1; for (; !isdigit(_ch) &amp;&amp; (_ch != '-') &amp;&amp; (_ch != EOF); _ch = getchar()) ; if (_ch == '-') &#123; _f = 0; _ch = getchar(); &#125; for (; isdigit(_ch); _ch = getchar()) _x = _x * 10 + _ch - '0'; return _f ? _x : -_x;&#125;void write(ll _x) &#123; if (_x &gt;= 10) write(_x / 10), putchar(_x % 10 + '0'); else putchar(_x + '0');&#125;inline void wrt(ll _x, char _p) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 400005struct LCT &#123; int son[maxn][2], val[maxn], sum[maxn], fa[maxn], cnt; inline bool isroot(int x) &#123; return son[fa[x]][1] != x &amp;&amp; son[fa[x]][0] != x; &#125; inline void update(int x) &#123; sum[x] = sum[son[x][0]] + sum[son[x][1]] + val[x]; &#125; inline void rotate(int x) &#123; int y = fa[x], z = fa[y], d = son[y][1] == x; if (!isroot(y)) son[z][son[z][1] == y] = x; fa[y] = x, fa[x] = z; fa[son[x][!d]] = y, son[y][d] = son[x][!d]; son[x][!d] = y; update(y), update(x); &#125; inline void splay(int x) &#123; for (; !isroot(x);) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) (son[y][1] == x) ^ (son[z][1] == y) ? rotate(x) : rotate(y); rotate(x); &#125; &#125; inline int access(int x) &#123; int t = 0; for (; x; t = x, x = fa[x]) splay(x), son[x][1] = t, update(x); return t; &#125; inline void link(int u, int v) &#123; fa[v] = u; &#125;//因为先有cut所以可以不access inline void cut(int u) &#123; access(u); splay(u); fa[son[u][0]] = 0, son[u][0] = 0; &#125; inline int dis(int x, int y) &#123; int Sum = 0; access(x); splay(x); Sum += sum[x]; int lca = access(y); splay(y); Sum += sum[y]; access(lca); splay(lca); Sum -= sum[lca] &lt;&lt; 1; return Sum; &#125; inline void changefa( int x, int y) // xxc's fahter was hje before,but now his father is me &#123; cut(x); link(y, x); &#125; inline int getfather(int x) &#123; access(x); splay(x); return son[x][0]; &#125; inline int new_node(int x) &#123; sum[++cnt] = x, val[cnt] = x; return cnt; &#125;&#125; lct;int to[maxn];int cl[maxn], cr[maxn], ans[maxn];int n, m, p, r, cnt, QwQ;struct Query &#123; int op, w, x, y, id; bool operator&lt;(const Query &amp;B) const &#123; return (w &lt; B.w) || (w == B.w &amp;&amp; op &lt; B.op); &#125;&#125; Q[maxn &lt;&lt; 1];int main() &#123; n = rd(), m = rd(); to[1] = lct.new_node(1); lct.link(1, lct.new_node(0)); cl[1] = 1, cr[1] = n; int now = 2, w = 1; rep(i, 1, m) &#123; int op = rd(); if (op == 0) &#123; cl[++w] = rd(), cr[w] = rd(); lct.link(now, to[w] = lct.new_node(1)); &#125; else if (op == 1) &#123; int l = rd(), r = rd(), x = rd(), pre = now; l = std::max(l, cl[x]), r = std::min(r, cr[x]); if (l &gt; r) continue; now = lct.new_node(0); Q[++cnt].op = 1, Q[cnt].w = l, Q[cnt].x = now, Q[cnt].y = to[x]; Q[++cnt].op = 1, Q[cnt].w = r + 1, Q[cnt].x = now, Q[cnt].y = pre; lct.link(pre, now); &#125; else &#123; Q[++cnt].w = rd(); int x = rd(), y = rd(); Q[cnt].op = 2, Q[cnt].x = x, Q[cnt].y = y; Q[cnt].id = ++QwQ; &#125; &#125; std::sort(Q + 1, Q + 1 + cnt); rep(i, 1, cnt) &#123; if (Q[i].op == 1) lct.changefa(Q[i].x, Q[i].y); else ans[Q[i].id] = lct.dis(to[Q[i].x], to[Q[i].y]); &#125; rep(i, 1, QwQ) wrt(ans[i], '\n');&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about-zxy]]></title>
    <url>%2F2018%2F12%2F06%2Fabout-zxy%2F</url>
    <content type="text"><![CDATA[博客运行一段时间了，也有了一点文章了，该来个about me了 about我的ID我常以zxy_hhhh及地狱小鬼366(无法输入中文时为dyxg)的ID游荡于各大OJ、社交网站&amp;&amp;游戏 关于OI生涯去年拿了个pj1=，今天tg咕咕咕了不过1=还是有的；之后的么。。。待续 关于博客内容一般是一些题解或者对算法/数据结构的理解。 一些解释关于背景图都是妹子图，不过刷新一下会换一张，一共7张 关于加密文章虽然前端的加密是扯淡，因为一些政治原因无法公开 分享功能是GG的，请勿使用虽然我觉得不会有人去用 关于访问速度问题，因为我部署在github上的，国内访问速度就。。。不过，过几天我说不定会往coding上部署一份，届时访问速度就会好多了 头像什么的还在搞。。。 还有本人码风各种变换，原因有两个 1. 有时候我会用vscode格式化代码 2. 最近在改码风 如果有建议或意见或者要换友联，请用QQ或邮箱找我，留言的话也可以，不过有我可能无法第一时间看到（如果QQ找我请说明身份） 先写这么多吧，其他的想到了再补]]></content>
  </entry>
  <entry>
    <title><![CDATA[不勤劳的图书管理员]]></title>
    <url>%2F2018%2F12%2F05%2Fbzoj3110%2F</url>
    <content type="text"><![CDATA[暴力可以AC 题目链接 先算出不修改时的答案； 对于的位置i贡献就是 $\Sigma_{j=1}^{j&lt;i} a[j]+a[i] (v[j]&gt;v[i])$ 然后对于每一次修改，考虑对答案的影响就是y移到x减少的和x移到y增加的而影响只会出现在(x,y) 具体就是： (x,y)对x产生的逆序对，y对(x,y)产生的逆序对会失去 (x,y)对y产生的逆序对，x对(x,y)产生的逆序对会增加入答案 如何维护a[i]+a[j]? 用树套树维护(x,y)大于等于x的数的个数和这些数的和 不能用指针，不然空间会GG 要外层树状数组内层线段树，不然空间GG 外层线段树内层平衡树空间OK的，不过时间就呵呵了机房某大佬卡了一上午常之后彻底弃疗，写了暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* Author: zxy_hhhh date: 2018/12/05*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define mod 1000000007#define mid ((l + r) &gt;&gt; 1)#define lb(x) (x &amp; -x)#define maxn 50005int n, a[maxn], w[maxn], m, Ans;inline int Mod(int x) &#123; return x &lt; 0 ? (x + mod) : (x &gt;= mod ? x - mod : x); &#125;namespace xtree &#123;struct node &#123; int sum,ls,rs;&#125;tr[20000000];int cnt;void insert(int &amp;u, int l, int r, int x, int k) &#123; if (!u) u = ++cnt; tr[u].sum = Mod(tr[u].sum + k); if (l == r) return; if (x &lt;= mid) insert(tr[u].ls, l, mid, x, k); else insert(tr[u].rs, mid + 1, r, x, k);&#125;inline int query(int u, int l, int r, int ql, int qr) &#123; if (!u) return 0; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u].sum; return (query(tr[u].ls, l, mid, ql, qr) + query(tr[u].rs, mid + 1, r, ql, qr)) % mod;&#125;&#125; // namespace xtreestruct &#123; int tr[maxn]; inline void update(int x, int k, int val) &#123; for (; x &lt;= n; x += lb(x)) xtree::insert(tr[x], 1, n, k, val); &#125; inline int query(int x, int L, int R) &#123; int ans = 0; for (; x; x -= lb(x)) ans = Mod(ans + xtree::query(tr[x], 1, n, L, R)); return ans; &#125; inline int query(int L, int R, int l, int r) &#123; return Mod(query(R, l, r) - query(L - 1, l, r)); &#125;&#125; tr1, tr2;int main() &#123; n = rd(), m = rd(); rep(i, 1, n) &#123; w[i] = rd(), a[i] = rd(); tr1.update(i, w[i], a[i]), tr2.update(i, w[i], 1); Ans = Mod(Ans + tr1.query(i - 1, w[i], n)), Ans = Mod(Ans + 1ll * tr2.query(i - 1, w[i], n) * a[i] % mod); &#125; rep(i, 1, m) &#123; int x = rd(), y = rd(); if (x &gt; y) swap(x, y); if (x==y) &#123;wrt(Ans,'\n');continue;&#125; Ans = Mod(Ans - tr1.query(x + 1, y - 1, w[y], n)); Ans = Mod(Ans + tr1.query(x + 1, y - 1, w[x], n)); Ans = Mod(Ans - tr1.query(x + 1, y - 1, 1, w[x])); Ans = Mod(Ans + tr1.query(x + 1, y - 1, 1, w[y])); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, w[y], n) * a[y] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, w[x], n) * a[x] % mod); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, 1, w[x]) * a[x] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, 1, w[y]) * a[y] % mod); if (w[x] &gt; w[y]) Ans -= a[x] + a[y]; else Ans += a[x] + a[y]; Ans=Mod(Ans); tr1.update(x, w[x], -a[x]), tr1.update(x, w[y], a[y]); tr1.update(y, w[y], -a[y]), tr1.update(y, w[x], a[x]); tr2.update(x, w[x], -1), tr2.update(x, w[y], 1); tr2.update(y, w[y], -1), tr2.update(y, w[x], 1); swap(w[x], w[y]), swap(a[x], a[y]); wrt(Ans, '\n'); &#125; //wrt(xtree::cnt,'\n');&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学树套树]]></title>
    <url>%2F2018%2F12%2F05%2Ftree-tao-tree%2F</url>
    <content type="text"><![CDATA[最近写了点树套树，感觉也没那么可怕 主要思想很多用于动态维护区间的一些东西，比如：区间内大于等于x的数的个数、区间前驱后继等等 主要思想很简单，就是 对外层树的每一个节点建一个内层树 具体实现方式可见例题 来几个 栗子K大数查询二逼平衡树不勤劳的图书管理员先写到这里吧]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K大数查询]]></title>
    <url>%2F2018%2F12%2F03%2Fluogu-3759%2F</url>
    <content type="text"><![CDATA[模板题 题目链接 因为有区间修改，所以外层建权值线段树，内层建区间树 处理修改：对所有包含c的外层树节点所对应的内层树的a~b区间+1 处理询问：在外层树上二分，若当前节点的右子树的内层树a~b区间和&gt;c就往左子树走，否则往右 注意: 区间树要标记永久化，不然如果写的不够优秀会 MLE or TLE 此题luogu上时限只有1s，大部分代码包括本人代码会被卡常，获得0~100不等的分数。 在往左子树走时要减掉右子树a~b区间和带来的贡献 在具体实现的时候，我为了图方便用了指针和namespace 如果你看不懂指针，可以往下翻，有无指针的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* Author: zxy_hhhh date: 2018/12/01*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define mid ((l + r) &gt;&gt; 1)int n, m;namespace xtree &#123;struct node &#123; int lazy; ll sum; node *ls, *rs;&#125;;void insert(node *&amp;u, int l, int r, int ql, int qr) &#123; if (u == NULL) u = new node; if (ql == l &amp;&amp; r == qr) &#123; u-&gt;lazy++, u-&gt;sum += r - l + 1; return; &#125; u-&gt;sum += qr - ql + 1; if (qr &lt;= mid) insert(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) insert(u-&gt;rs, mid + 1, r, ql, qr); else insert(u-&gt;ls, l, mid, ql, mid), insert(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;ll query(node *u, int l, int r, int ql, int qr) &#123; if (u == NULL) return 0; if (ql == l &amp;&amp; qr == r) return u-&gt;sum; ll ans = (qr - ql + 1) * u-&gt;lazy; if (qr &lt;= mid) return ans + query(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) return ans + query(u-&gt;rs, mid + 1, r, ql, qr); else return query(u-&gt;ls, l, mid, ql, mid) + ans + query(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;&#125;; // namespace xtreenamespace ytree &#123;struct node &#123; xtree::node *rt;&#125; tr[400005];void insert(int pos, int l, int r, int ql, int qr, int x) &#123; xtree::insert(tr[pos].rt, 1, n, ql, qr); if (l == r) return; if (x &lt;= mid) insert(pos &lt;&lt; 1, l, mid, ql, qr, x); else insert(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;int query(int pos, int l, int r, int ql, int qr, ll x) &#123; if (l == r) return l; ll sum = xtree::query(tr[pos &lt;&lt; 1 | 1].rt, 1, n, ql, qr); if (sum &gt;= x) return query(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x); else return query(pos &lt;&lt; 1, l, mid, ql, qr, x - sum);&#125;&#125;; // namespace ytreestruct Query &#123; int op, l, r; ll c;&#125; Q[maxn];int H[maxn], tot;int main() &#123; n = rd(), m = rd(); rep(i, 1, m) &#123; int op = rd(), l = rd(), r = rd(); ll x = rd(); if (op == 1) ytree::insert(1, -n, n, l, r, x); if (op == 2) wrt(ytree::query(1, -n, n, l, r, x), '\n'); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二逼平衡树]]></title>
    <url>%2F2018%2F12%2F03%2Fbzoj3196%2F</url>
    <content type="text"><![CDATA[码量稍微有大，不过思路清晰还是好写的 题目链接 外层线段树，内层平衡树 操作1 4 5就是在线段树上取出区间，然后平衡树内求答案，合并答案 修改也没什么好讲的，和上一题比较相似 操作2要二分答案，然后转化为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* Author: zxy_hhhh date: 2018/12/03*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define inf 2147483647#define mid ( (l + r) &gt;&gt; 1 int a[maxn], n, m;namespace xtree &#123;struct node *nil;struct node &#123; int sz, val, fix; node *ls, *rs; node(int x) : sz(1), val(x), fix(rand()) &#123; ls = rs = nil; &#125; inline void update() &#123; sz = ls-&gt;sz + rs-&gt;sz + 1; &#125;&#125;;inline void init() &#123; nil = new node(0); nil-&gt;ls = nil-&gt;rs = nil; nil-&gt;sz = 0;&#125;void split(node *now, int k, node *&amp;x, node *&amp;y, int op = 1) &#123; if (now == nil) &#123; x = y = nil; return; &#125; if (op == 1 ? now-&gt;val &lt; k : now-&gt;ls-&gt;sz &lt; k) &#123; x = now; split(now-&gt;rs, (op == 1 ? k : k - now-&gt;ls-&gt;sz - 1), x-&gt;rs, y, op); x-&gt;update(); &#125; else &#123; y = now; split(now-&gt;ls, k, x, y-&gt;ls, op); y-&gt;update(); &#125;&#125;node *merge(node *x, node *y) &#123; if (x == nil) return y; if (y == nil) return x; if (x-&gt;fix &lt; y-&gt;fix) &#123; x-&gt;rs = merge(x-&gt;rs, y); return x-&gt;update(), x; &#125; else &#123; y-&gt;ls = merge(x, y-&gt;ls); return y-&gt;update(), y; &#125;&#125;inline void insert(node *&amp;rt, int val) &#123; node *x, *y; split(rt, val, x, y); rt = merge(x, merge(new node(val), y));&#125;inline void del(node *&amp;rt, int val) &#123; node *x, *y, *z; split(rt, val, x, y); split(y, 1, y, z, 2); rt = merge(x, z);&#125;inline int pre(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val, x, y), split(x, x-&gt;sz - 1, x, z, 2); if (z == nil) ans = -inf; else ans = (z-&gt;val); rt = merge(x, merge(z, y)); return ans;&#125;inline int nxt(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val + 1, x, y), split(y, 1, y, z, 2); if (y == nil) ans = inf; else ans = y-&gt;val; rt = merge(x, merge(y, z)); return ans;&#125;inline int rank(node *&amp;rt, int val) &#123; node *x, *y; int ans; split(rt, val, x, y); if (x == nil) ans = 0; else ans = x-&gt;sz; rt = merge(x, y); return ans;&#125;&#125; // namespace xtreenamespace ytree &#123;xtree::node *tr[maxn &lt;&lt; 2];inline int pre(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return -inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::pre(tr[pos], x); return max(pre(pos &lt;&lt; 1, l, mid, ql, qr, x), pre(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int nxt(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::nxt(tr[pos], x); return min(nxt(pos &lt;&lt; 1, l, mid, ql, qr, x), nxt(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int rank(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::rank(tr[pos], x); return rank(pos &lt;&lt; 1, l, mid, ql, qr, x) + rank(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;inline void change(int pos, int l, int r, int x, int v) &#123; xtree::del(tr[pos], a[x]), xtree::insert(tr[pos], v); if (l == r) return; if (x &lt;= mid) change(pos &lt;&lt; 1, l, mid, x, v); else change(pos &lt;&lt; 1 | 1, mid + 1, r, x, v);&#125;inline int atrank(int L, int R, int k) &#123; int l = 0, r = 100000000, ans; while (l &lt;= r) &#123; if (rank(1, 1, n, L, R, mid) &lt; k) ans = mid, l = mid + 1; else r = mid - 1; &#125; return ans;&#125;void build(int pos, int l, int r) &#123; tr[pos] = xtree::nil; rep(i, l, r) xtree::insert(tr[pos], a[i]); if (l == r) return; build(pos &lt;&lt; 1, l, mid), build(pos &lt;&lt; 1 | 1, mid + 1, r);&#125;&#125; // namespace ytreeint main() &#123; n = rd(); m = rd(); xtree::init(); rep(i, 1, n) a[i] = rd(); ytree::build(1, 1, n); rep(i, 1, m) &#123; int op = rd(); if (op == 1) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::rank(1, 1, n, l, r, x) + 1, '\n'); &#125; else if (op == 2) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::atrank(l, r, x), '\n'); &#125; else if (op == 3) &#123; int x = rd(), k = rd(); ytree::change(1, 1, n, x, k); a[x] = k; &#125; else if (op == 4) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::pre(1, 1, n, l, r, x), '\n'); &#125; else if (op == 5) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::nxt(1, 1, n, l, r, x), '\n'); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F11%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[暂时当更新日志用12.4 8:54 update头像好像出了点锅，先拿默认的顶一顶，争取晚上解决吧;其他基本解决12.5 15:53 update因为晚上断网了，所以头像咕咕咕了；我还是先写点东西吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[ss]]></title>
    <url>%2F1028%2F12%2F06%2Fmy-ss%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX19Oc7vYwpC2niIQzlEI0QwUJ3QIRf0kgiCsZXRB+b8eBEkoWIwyw+R0Vvm8Qxk5GXtgOGsOyMtDWa6EUbPQEAwJvaUMXs7KKFaq65P39N0RZkGoOviuPPb18NAYMAzUz8gHcYjZbL/ocWHyirRJguBq2MSwm3PkrxLVjkwEoByfKpNN8WPJquBWfoRSKImFfiFcVd82gqgUniOBRU7r0Kgqbri4j9WoU6gAz8mCUZCSJcpg7zFFSdwR3t7l0mdRIuBi02Pv8mb+s8hgsI9GXhW0MWvmeFUCfZrsorWkF5vAqgWHTYUYoOMxhU9AifR9M0T+3GSLW4ve/DE3V88/fpOTMLP2jx/jwXcwFqGof+23wTwE2dSgSaF9fEv+aLAbLqZeZZM3xq8hyuzgbNFUWxpJadTQYLQh/E81qguREsBPP71YS2L+wbNXj+KuPT0ENEE7pjizoLpqUnU2QWWlxnMD87MoZs8FGueD7Mxi5CxkqEBrNmaTOTU8NHSNdLUrkJY7Yn/apJTJizD33XNk1mtYo2KuplwwImdGz1TXCBeNZANVUsl++z/DPjRPgmGEIAwWz96295SWeI9hpIYEvmUaJFEa9wgTqGXYM11oX4Dmp9wgCYMocZvou8+v4JwwsPVWHwC6w6i8U9nL/vk6iyIoavx1PB/HlSZFKJrBoGVcYOepPI8QanOuqUVeuowdIetwape7qDlPKBo3Hmjo7NOMoPECg3gHjX6/upF/ZNRokfDKS8zjSAA072if30afTX17XI+3LtOFA2tHD1w95KZz8/fzql3iLn142yxubC7oPHeckfz9xFfDET0i7PZx11UywHVd4Dk2/sDWVEY0TBiFgm24Yu/NiLUd9eEWJqKydehV7zqZV2kXB4EwF+3MrofWLrJVvpyGmNSYtK0X0IPfOLghltSKWif+/G5tpFXcNgEPXqRmfPXGhodFeSJTCLC7ZsUUdFFFSgE2DbfnCKdwGbbB8Lu8sC8Ue53ePdHbgpOHFed315/cSfIJBE33brBFLmrqtwWZB8Ys/sAqeLZfc+OYZOMoiAdxiL3/MwclXSzXU0xMKew44zpha8+AEiwClnivEFSSNJujgA842y4937UgvyGKO5tI9DGpHv3iDzRHrgSJeTpUrbLFnyTa+MRNC5iCXujKdk/IJKWuH19JczPkh6l2OxGl/oKm8Z4ZiVZP3oi51iWVcV/9FCyZQT9TsJ/oK/nE2WVq5u3YyQjk4KYjNucH5IhvCOkykFjwK8KBEAWmQrR/1aaV07UT7QpWMol0PUvtITisSNdJs7EUuX9wsuoYX0n11hHggLy0dTe8AfKqisVsZQaVARS99qJLYyYPegnt/ExoFS3TekDg2Bx2wgVYqemoTmsNaCXJO1D4Ed7fFrFmRxBhMWD5OkAU8nzPG6cXbgW6qSFL+7qw1zpCLSpj/9U+DnQWJJOTzmDhYKkGQFktKHbUmu3JGEw05P+o4Zs5+j+QBddFithm+8yC9GtZa3VwldK3eO6Aegjlwq34z/5A18OyrncVdK2SrATgDoqr0Ks/aNS0l0z1Unzomuu0/30AFUNWA2AL5xpuF0YGJ0OS7lViJFVCvigZF4PMKPojogo4bWb8Xk498znZXmdn6AjZyJkFjc2wlxYV1faUKJSMzNIJP5qzdGENDT/yatRORrk+grHOf+1rqLynsfyJB6ubisulM9zoX6M0S+m/RSfE7wH4vGt1ebsRvfore4Eq4vQO19bKQ25B39KHOfzX/bKX6wKd7Ues9hqci2mwyLTkGj881UZ7t5ul+n5ziWMCQEuyLOy5auCjfVZDrIgjFXnvPAVwUopwPHUZQlGXoU0WNfQHRLgmMcQg89DLJ/hNY0EqnuQu9WpW6kiVbUveKsiZ5WoExDvqG1ot6wyXRK5n8jZcurt9J8TsnwNsCR1am3F43PDCJEPa1vp2rP3Gn5MdtZayjhsADUuhP/N2ckNx+goxY76kBVUZqOSbRRbE6mxng8KbqSmKsDJixRgDSzt5aDPXqE449Un5k4lAFkPjWmWeR4etB2E/rKutTMnqyDUY7vQD6scbWP0/5lj8YFYA6axSlupfZHTjftbB+vnthZiybpNYpZDCpqZtt5E4WvQ+xncFUXSf/zcj83zcU86fdT1Ky61IfsxXIbGurSWX+B686Qur9yF7BIfD4GTicqWj2t5WRpdmHITVKqVYKnGdPa3Cm9bQB1o8Lcah/82PO6LepH6OY2UCdAxIFPVyxf+NTCypfIbNF6zi23gcsHh1e/zckYnKe7IYkibLhQcrm3RoMEmp4pcVVbq0WETfUHyAHxJS0pBnu3aPfw6Tvtrmt6cs7BPVOZJWbWXuEAc+KL5JMpl3q+5Cgmym9UKReF1gIP7XD8CProM7OFRw0lZNRridju3XVVvTQhIMFSgIkws05fMi6PElN3o7e78kZo9NfzxVPC4z/wYWkFiyt4p0/eOe/ppKRvMJenicdX8Ot4Iff/TNseYEjj24c1kboXSnfg97SqMRTTQX8j18VUz+uYXZFDmwAo99n3zWm3etCozVHrc7Vx18QF7SkRt6cVuSLnu4H4CG+hN3DTLdxXgPiSfPTzq29D70w5/Er6PN6oGspKI2X+8d7sjqfZtmRgFZ/eKHEiWI9VESRSNKHUV4x5m6q1DV8j4J9REEfjv+Fa0/Ls5wtnWH/yZhqYnBjwO9rWqHGLPG1NF/5AuYw5NEnkEIKcwLF0dG40les29k0yg/X7Hh2KNF+4ZUilbiJjJzSt7IHJnea+GPXFykkAtxTLQey44LpH+VcInOwnCejb4W8HzZ3Poi22m8EJthDD4D6NStB3kawH9Cb/CjK+gd4oMvogvrEjZpK5weekPAemeuLUiA9G48IgiMfWNBojJkFvERLtMfIBlwCeMiE+P0KIO1iQz5rz/9NZFvcuvkbF3PKH7x8jomBHd/b1gkcNxHDqx2kuC47ljhWiO0guwnzSCzbl7plWu8V8Cu1SngnvIUsBEE+eEw6xhci1XLxy6wJU8ZEpmMpI6qN8U41SgDDKDEivWByLl/2pAVi4sTGKRdzTQ1oar9VQ+UUN0M24MF2nhTTReiuL4EeYjZfFGhASYof4eZr5l2YnqnrC1SNe63JogO/SSX2W5HQE5m+xWN29aF+AOqPyWYYT6txALqAPJxgBPbuCqdDu4IXej7oFR29pLk2ZvT3dEHCs5gMObr6siCXisUrUwGa8AgRUHU7z59Dw4pO7gvD9ylt+V2DNKys99bDCLxgOf3RkJj89I6lL3XLow5F23QnuSSQ63zrlR4afwTyjMM1fcXMrlwQmP761+IA5WhjWBEn2rSfNkuUlezSs5nUiZc0JaEOgSYlGZY/iKfV9NSevBEuwH6za/qPRiJ0dhC1dkZYGj4FdHHOqSK5m/EAKQTAIHY2V1xonxXUBckrGyxhZJxVJni9bAMi/RMjV1hCqEqYayj6tWxTghdiBaXBGViHjDYlrFZYYIVt922AhQFDIH5pnE58tSpeUdlfadlkeoFQBERWVgOCN0FEQHhRNlrKYyM8XIGg2PRBImJEoG8SRwLpbORurmh0PkWW/kGV0W5vHXi72cqdSQM8EJ2phX8gkFFUmmhwd+EaDFTviojw4APMvrcZnWV6TpNx01QgPRDhRS5fpLbRKrpMgPWIv2kqeBUzf41soGeBdgUrrr8HwkZ3ZpsV6TNSQV8+HmWUwP2RRGt8MFrIemMYSgbueUgS+iXpEW5UuwToMmh2VzGSwTcG1zjIDJpeJZ/ezW4cd4eBw0/RH54CS4BRHCfii31rg3y/G1S2IWItMlk6ff+4LRUp0U38Bo0YY+nv3ZwgK+ULH2rD14utls0fq+S55w15VCImANNTfXuJEjJZfiyNh9tw+4PyTHUt7DCj5Mj4/brefTMmRsU6HT9omyyCeY6dalq2e1rMRIYzMjDkSYe1FqzyrZYLWMrsz+XwVhqivXbmVxnDseJd8bn/kPTxGXw385IQYnxW4HTcHG5UsYhEQozqAOi3fAA9KZ/nhk4I7zezXyKJhcdQvEMgF8k+iBsUujcf95N/DuFYsTed4EBJqyKLiZdOyaWea7FEt8vMmJhScjERTcv/PFK7GPn/HtuaRS+nFBffY3pTKf+QYSMA+fQvcsyN9j8HIk3Q++Rwpz89+YXkkQgtzQgvuAYXxihBh+50jCdshIjGvJYzQ7vFVm6hK/s62f/NC2pKyUS8XGPhuH75hOUbolk63IPVtOc1IJ0VzeDoLF0giBHkwNIImffMB972TxeJGgxKiogFiF9uxRm4/5Ihu7nRiOIkpOlfOck6+OTzrY0FaWhzzcFBIGfGR1b/1tpS9x8EhBA0rbgvAlkXEHPsQK11EsARYu7mwdeNeybzg434yLHNh9JuDv7t4BXLd7dh83a4xi7kTjWv4AgzX8lz/dVBnc+Rs6Eu7GOJKGsxmsirOATnDwMlFdCGfKrCxbE0GgO86+totVJCD8HzmaAvxGNSkzp5zJ4w5G3S9O22wXQSU0qHGKtypBmhh4jB2y8LAac/ouKwJPoGgvC3RVDx6JoW5sFBvWUBFMvtceKh9TiqjWTvvilogMS5Te4V1SPvUmyaD+zMWjUyijL+ENJiKyue++jQOxhnst8lrHs+fjwq861fvGwimnjnH8wSFt2DE2maSjL5KznpunJy6wGMMWAeDsBz33ghT8K5PjGKKpmDjYKHWFbik/lqo6SoXULKi2IHSvRwSHlJpQSmVVYfWrkFe6UIyZMJw6sMRS9r7aVjrMOxvXAjCjr2Rv1lX3CLcPSz69HpGZvCytJicBOjru6qv86HnCcFuyBf2lRH1zMmGT973ML8cvVn97nHC54i9ZaRZCc2trLoev9f9OStjSZ3QU/eYmVdIV40qWGUhwaXcl5r09fVPP5nU6wK/KjgmrbgFwMK6kV0rZnvy40AZndUW1IgcMlaxRJRE0qosA8lWF5x+we+g+V4TRyGZd+XBAFNTUYtAyYHC6wtOIdQ8P/JtILP97JMfnG9wOyF/Fu5NoyaNfPradx/ax7TfEJtb4u0ZLLvNf03i6fkg==]]></content>
  </entry>
</search>
