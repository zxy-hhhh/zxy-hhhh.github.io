<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[铁人两项]]></title>
    <url>%2F2019%2F01%2F09%2Fluogu-4630%2F</url>
    <content type="text"><![CDATA[圆方树入门 题目链接 转化一下题意，等价于求$\sum\limits_x\sum\limits_y S_{x,y}$ $S_{x,y}$表示$x$到$y$的所有不经过重复点的路径可能经过的点的个数 建出圆方树，方点权值为点双大小，圆点权值为$-1$，问题就变成了求树上所有圆点对的路径长度之和 路径长度定义为树上两点路径经过点的权值和（包含这两点）。 每个点的贡献就是经过它的路径数$×$它的权值 注意：图不一定联通 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 600005#define maxm 600005int tot,n,m;namespace Tree&#123; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn&lt;&lt;1],cnt; inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125; int g[maxn&lt;&lt;1],mx; ll ans; int dfs(int u,int fa) &#123; int sum=u&lt;=n; cross(i,u) if (to[i]!=fa) &#123; int x=dfs(to[i],u); ans+=2ll*g[u]*x*sum; sum+=x; &#125; ans+=2ll*g[u]*sum*(mx-sum); return sum; &#125;&#125;int dfn[maxn],low[maxn],id;int sta[maxn],top; int nx[maxm],to[maxm],hd[maxn],cnt;inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125;void tarjan(int u,int fa) &#123; Tree::mx++; dfn[u]=low[u]=++id; sta[++top]=u; for(int i=hd[u];i;i=nx[i]) if (to[i]!=fa) &#123; int v=to[i]; if (!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); if (low[v]&gt;=dfn[u]) &#123; //对于一般图，此处为&gt;=；对于仙人掌，此处为== tot++;Tree::g[n+tot]=2; while(sta[top]!=v) Tree::g[n+tot]++,Tree::add(n+tot,sta[top--]); Tree::add(n+tot,sta[top--]); Tree::add(u,n+tot); &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125;void init(int n)&#123; rep(i,1,n) Tree::g[i]=-1; rep(i,1,n) if (!dfn[i]) &#123; Tree::mx=0; tarjan(i,0),Tree::dfs(i,0); &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int x=rd(),y=rd(); add(x,y),add(y,x); &#125; init(n); wrt(Tree::ans,'\n');&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆方树]]></title>
    <url>%2F2019%2F01%2F08%2Fyuanfangshu%2F</url>
    <content type="text"><![CDATA[圆方树题的整理和一个模板 圆方树初学的话点这里 然后放个建树模板 1234567891011121314151617181920void tarjan(int u,int fa) &#123; Tree::mx++; dfn[u]=low[u]=++id; sta[++top]=u; for(int i=hd[u];i;i=nx[i]) if (to[i]!=fa) &#123; int v=to[i]; if (!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); if (low[v]&gt;=dfn[u]) &#123; //对于一般图，此处为&gt;=；对于仙人掌，此处为== tot++; while(sta[top]!=v) Tree::add(n+tot,sta[top--]); Tree::add(n+tot,sta[top--]); Tree::add(u,n+tot); &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125; problems铁人两项]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小清新数据结构题]]></title>
    <url>%2F2019%2F01%2F06%2Fluogu-3676%2F</url>
    <content type="text"><![CDATA[真是小清新 题目链接 题意查询以$x$为根时的所有子树的权值和的平方和，带单点修改、 做法为了表达方便，记$q$为询问的点，我们用$x$表示$1$到$q$路径上的点 可以先$O(n)$的处理出以$1$为根时：​ 答案，记为$Ans$ ​ 每颗子树的权值和，记为$S_i$ ​ 所有点权值和，记为$Sum$ ​ 点的深度，记为$dep_i$，$dep_1=1$ 考虑修改修改点$q$，记原来值和当前值差为$d$ $Sum=Sum+dep_x*d$ $Ans=Ans-\sum\limits_x(S_x)^2+\sum\limits_x(S_x+d)^2$ $=Ans-\sum\limits_x(S_x)^2+\sum\limits_x(S_x)^2+2S_xd+d^2$ $=Ans+\sum\limits_{x}2S_xd+d^2$ $=Ans+2 d\sum\limits_x S_x+dep_x d^2$ 所有$S_x=S_x+d$ 当根换为$q$时此时点$x$，不含点$q$，$S_x$会变为$Sum-S_{son}$，$S_{son}$表示$x$的包含点$q$的子树的大小 其余点不变 所以答案为 $Ans-\sum\limits_x(S_x)^2+Sum^2+\sum\limits_x(Sum-S_x)^2$ $=Ans+\sum\limits_x(Sum-S_x)^2-(S_x)^2+Sum^2$ 平方差公式展开 $=Ans+Sum^2+\sum\limits Sum(Sum-2S_x)$ $=Ans+Sum^2+Sum\sum\limits Sum-2S_x$ $=Ans+Sum^2+Sum^2dep_x+2Sum\sum\limits S_x$ 用树剖+树状数组维护链上加，链上求和就好了 代码时间复杂度$O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* &gt;Author: zxy_hhhh &gt;blog: zxy-hhhh.cn &gt;date: 2019/01/04*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 200005namespace Tree_Array&#123; ll sum[maxn],Sum[maxn]; int n; inline void add(int x,int val) &#123; for(int i=x;i&lt;=n;i+=i&amp;(-i)) sum[i]+=val,Sum[i]+=1ll*x*val; &#125; inline ll getsum(int x) &#123; ll ans=0; for(int i=x;i;i-=i&amp;(-i)) ans+=(x+1)*sum[i]-Sum[i]; return ans; &#125; inline void update(int l,int r,int x) &#123;add(l,x),add(r+1,-x);&#125; inline ll query(int l,int r)&#123;return getsum(r)-getsum(l-1);&#125;&#125;namespace Tree&#123; int n; int nx[maxn&lt;&lt;1],to[maxn&lt;&lt;1],hd[maxn],cnt; inline void add(int u,int v)&#123;nx[++cnt]=hd[u],to[cnt]=v,hd[u]=cnt;&#125; int top[maxn],sz[maxn],fa[maxn],son[maxn],dep[maxn]; int val[maxn],a[maxn]; int sum[maxn]; ll Ans,S; int idx[maxn],id; void dfs(int u) &#123; dep[u]=dep[fa[u]]+1,sz[u]=1;sum[u]=a[u]; cross(i,u) if (to[i]!=fa[u])&#123; fa[to[i]]=u,dfs(to[i]); sz[u]+=sz[to[i]],sum[u]+=sum[to[i]]; if (sz[son[u]]&lt;sz[to[i]]) son[u]=to[i]; &#125; &#125; void dfs(int u,int tp) &#123; idx[u]=++id;val[id]=a[u]; top[u]=tp; if (son[u]) dfs(son[u],tp); cross(i,u) if (to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs(to[i],to[i]); &#125; inline void init() &#123; dfs(1),dfs(1,1); Tree_Array::n=id; rep(i,1,id) Tree_Array::update(idx[i],idx[i],sum[i]),Ans+=sum[i]*sum[i]; S=sum[1]; &#125; inline void link_update(int x,ll val) &#123; while(1)&#123; Tree_Array::update(idx[top[x]],idx[x],val); if (top[x]==1) return ; x=fa[top[x]]; &#125; &#125; inline ll sigma(int x) &#123; ll ans=0; while(1)&#123; ans+=Tree_Array::query(idx[top[x]],idx[x]); if (top[x]==1) return ans; x=fa[top[x]]; &#125; &#125; inline ll query(int x) &#123;return Ans+S*S+1ll*dep[x]*S*S-2ll*S*sigma(x);&#125; inline void update(int x,ll val) &#123; ll delta=val-a[x],s1=sigma(x),s2=dep[x]; Ans+=2*s1*delta+delta*delta*dep[x]; S+=delta; link_update(x,delta); a[x]=val; &#125;&#125;using namespace Tree;int main()&#123; n=rd(); int m=rd(); rep(i,1,n-1) &#123; int x=rd(),y=rd(); add(x,y);add(y,x); &#125; rep(i,1,n) a[i]=rd(); init(); rep(_i,1,m)&#123; int op=rd(); if (op==1)&#123; int x=rd(),val=rd(); update(x,val); &#125; else &#123; int x=rd(); wrt(query(x),'\n'); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大森林]]></title>
    <url>%2F2018%2F12%2F13%2Fbzoj4573%2F</url>
    <content type="text"><![CDATA[有趣的LCT题 题目链接 写在前面的一些结论： 合法的$2$操作只会在一段连续的区间内发生，所以合法$2$操作也只会在一段区间内发生，因此我们可以把更换生长节点的区间，和加点区间取并，使$2$操作一定合法 如果$2$操作一定合法，加点操作区间从l~r变为1~n并不影响答案 一个询问在该询问进入时处理，和之后处理，答案并不改变，并且只有涉及到该树的操作才会对这个询问产生影响 结论是显然的 知道这些之后，来考虑如何解决； 一个想法可以基于上面结论，产生一个愚蠢的想法 设$x$为$2$操作后的生长节点，$y$为之前的 将$2$操作拆成两次： 在$l$处，将之后加入所有点，换到$x$下面 在$r+1$处,将之后加入所有点，换回$y$下面 然后将询问和$2$操作按位置排序，从1~n扫一遍，依次处理就得到了$O(n^{2})$的优秀做法 那么如何优化虚点!!!对每一个$2$操作建一个虚点，每个虚点的父节点是前一个虚点，第一个虚点的父亲是1 每一次加点就加到当前最后一个虚点下面就好了。 每次移动就直接将该$2$操作对应的虚点及其子树移到新的生长节点下然而还是T 统计答案我们让虚点权值为0，实点为1 设一个点i到根路径上权值和为 $S_{i}$(包含自身权值) $dis(u,v)=S_{u}+S_{v}-2S_{lca}$ 大家举几个栗子，想象一下，就知道这是对的。我不会证 LCT大法吼！！！移动子树相当于换父亲，LCT就可以了。 但是此处LCT 不能换根，因为有虚点，不同于普通树上路径，所以根的位置对答案会产生影响。 此处cut操作一定是儿子cut父亲，所以直接cut掉就可以了，like this1access(u);splay(u);fa[son[u][0]]=0,son[u][0]=0; 而link操作也一定是一颗树的根去link，所以也直接link就好了，像这样1access(v),splay(v),fa[v]=u; 然后就愉快的A了此题，时间复杂度$O(nlogn)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/* Author: zxy_hhhh date: 2018/12/07*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longinline ll rd() &#123; ll _x = 0; int _ch = getchar(), _f = 1; for (; !isdigit(_ch) &amp;&amp; (_ch != '-') &amp;&amp; (_ch != EOF); _ch = getchar()) ; if (_ch == '-') &#123; _f = 0; _ch = getchar(); &#125; for (; isdigit(_ch); _ch = getchar()) _x = _x * 10 + _ch - '0'; return _f ? _x : -_x;&#125;void write(ll _x) &#123; if (_x &gt;= 10) write(_x / 10), putchar(_x % 10 + '0'); else putchar(_x + '0');&#125;inline void wrt(ll _x, char _p) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 400005struct LCT &#123; int son[maxn][2], val[maxn], sum[maxn], fa[maxn], cnt; inline bool isroot(int x) &#123; return son[fa[x]][1] != x &amp;&amp; son[fa[x]][0] != x; &#125; inline void update(int x) &#123; sum[x] = sum[son[x][0]] + sum[son[x][1]] + val[x]; &#125; inline void rotate(int x) &#123; int y = fa[x], z = fa[y], d = son[y][1] == x; if (!isroot(y)) son[z][son[z][1] == y] = x; fa[y] = x, fa[x] = z; fa[son[x][!d]] = y, son[y][d] = son[x][!d]; son[x][!d] = y; update(y), update(x); &#125; inline void splay(int x) &#123; for (; !isroot(x);) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) (son[y][1] == x) ^ (son[z][1] == y) ? rotate(x) : rotate(y); rotate(x); &#125; &#125; inline int access(int x) &#123; int t = 0; for (; x; t = x, x = fa[x]) splay(x), son[x][1] = t, update(x); return t; &#125; inline void link(int u, int v) &#123; fa[v] = u; &#125;//因为先有cut所以可以不access inline void cut(int u) &#123; access(u); splay(u); fa[son[u][0]] = 0, son[u][0] = 0; &#125; inline int dis(int x, int y) &#123; int Sum = 0; access(x); splay(x); Sum += sum[x]; int lca = access(y); splay(y); Sum += sum[y]; access(lca); splay(lca); Sum -= sum[lca] &lt;&lt; 1; return Sum; &#125; inline void changefa( int x, int y) // xxc's fahter was hje before,but now his father is me &#123; cut(x); link(y, x); &#125; inline int getfather(int x) &#123; access(x); splay(x); return son[x][0]; &#125; inline int new_node(int x) &#123; sum[++cnt] = x, val[cnt] = x; return cnt; &#125;&#125; lct;int to[maxn];int cl[maxn], cr[maxn], ans[maxn];int n, m, p, r, cnt, QwQ;struct Query &#123; int op, w, x, y, id; bool operator&lt;(const Query &amp;B) const &#123; return (w &lt; B.w) || (w == B.w &amp;&amp; op &lt; B.op); &#125;&#125; Q[maxn &lt;&lt; 1];int main() &#123; n = rd(), m = rd(); to[1] = lct.new_node(1); lct.link(1, lct.new_node(0)); cl[1] = 1, cr[1] = n; int now = 2, w = 1; rep(i, 1, m) &#123; int op = rd(); if (op == 0) &#123; cl[++w] = rd(), cr[w] = rd(); lct.link(now, to[w] = lct.new_node(1)); &#125; else if (op == 1) &#123; int l = rd(), r = rd(), x = rd(), pre = now; l = std::max(l, cl[x]), r = std::min(r, cr[x]); if (l &gt; r) continue; now = lct.new_node(0); Q[++cnt].op = 1, Q[cnt].w = l, Q[cnt].x = now, Q[cnt].y = to[x]; Q[++cnt].op = 1, Q[cnt].w = r + 1, Q[cnt].x = now, Q[cnt].y = pre; lct.link(pre, now); &#125; else &#123; Q[++cnt].w = rd(); int x = rd(), y = rd(); Q[cnt].op = 2, Q[cnt].x = x, Q[cnt].y = y; Q[cnt].id = ++QwQ; &#125; &#125; std::sort(Q + 1, Q + 1 + cnt); rep(i, 1, cnt) &#123; if (Q[i].op == 1) lct.changefa(Q[i].x, Q[i].y); else ans[Q[i].id] = lct.dis(to[Q[i].x], to[Q[i].y]); &#125; rep(i, 1, QwQ) wrt(ans[i], '\n');&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about-zxy]]></title>
    <url>%2F2018%2F12%2F06%2Fabout-zxy%2F</url>
    <content type="text"><![CDATA[博客运行一段时间了，也有了一点文章了，该来个about me了 about我的ID我常以zxy_hhhh及地狱小鬼366(无法输入中文时为dyxg)的ID游荡于各大OJ、社交网站&amp;&amp;游戏 关于OI生涯去年拿了个pj1=，今天tg咕咕咕了不过1=还是有的；之后的么。。。待续 关于博客内容一般是一些题解或者对算法/数据结构的理解。 一些解释关于背景图都是妹子图，不过刷新一下会换一张，一共7张 关于加密文章虽然前端的加密是扯淡，是作为本人云剪切版用的，因为一些政治原因无法公开 分享功能是GG的，请勿使用虽然我觉得不会有人去用 关于访问速度问题，因为我部署在github上的，国内访问速度就。。。不过，过几天我说不定会往coding上部署一份，届时访问速度就会好多了 头像什么的还在搞。。。 如果有建议或意见或者要换友联，请用QQ或邮箱私信我，留言的话也可以，不过有我可能无法第一时间看到 先写这么多吧，其他的想到了再补]]></content>
  </entry>
  <entry>
    <title><![CDATA[不勤劳的图书管理员]]></title>
    <url>%2F2018%2F12%2F05%2Fbzoj3110%2F</url>
    <content type="text"><![CDATA[暴力可以AC 题目链接 先算出不修改时的答案； 对于的位置i贡献就是 $\Sigma_{j=1}^{j&lt;i} a[j]+a[i] (v[j]&gt;v[i])$ 然后对于每一次修改，考虑对答案的影响就是y移到x减少的和x移到y增加的而影响只会出现在(x,y) 具体就是： (x,y)对x产生的逆序对，y对(x,y)产生的逆序对会失去 (x,y)对y产生的逆序对，x对(x,y)产生的逆序对会增加入答案 如何维护a[i]+a[j]? 用树套树维护(x,y)大于等于x的数的个数和这些数的和 不能用指针，不然空间会GG 要外层树状数组内层线段树，不然空间GG 外层线段树内层平衡树空间OK的，不过时间就呵呵了机房某大佬卡了一上午常之后彻底弃疗，写了暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* Author: zxy_hhhh date: 2018/12/05*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define mod 1000000007#define mid ((l + r) &gt;&gt; 1)#define lb(x) (x &amp; -x)#define maxn 50005int n, a[maxn], w[maxn], m, Ans;inline int Mod(int x) &#123; return x &lt; 0 ? (x + mod) : (x &gt;= mod ? x - mod : x); &#125;namespace xtree &#123;struct node &#123; int sum,ls,rs;&#125;tr[20000000];int cnt;void insert(int &amp;u, int l, int r, int x, int k) &#123; if (!u) u = ++cnt; tr[u].sum = Mod(tr[u].sum + k); if (l == r) return; if (x &lt;= mid) insert(tr[u].ls, l, mid, x, k); else insert(tr[u].rs, mid + 1, r, x, k);&#125;inline int query(int u, int l, int r, int ql, int qr) &#123; if (!u) return 0; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u].sum; return (query(tr[u].ls, l, mid, ql, qr) + query(tr[u].rs, mid + 1, r, ql, qr)) % mod;&#125;&#125; // namespace xtreestruct &#123; int tr[maxn]; inline void update(int x, int k, int val) &#123; for (; x &lt;= n; x += lb(x)) xtree::insert(tr[x], 1, n, k, val); &#125; inline int query(int x, int L, int R) &#123; int ans = 0; for (; x; x -= lb(x)) ans = Mod(ans + xtree::query(tr[x], 1, n, L, R)); return ans; &#125; inline int query(int L, int R, int l, int r) &#123; return Mod(query(R, l, r) - query(L - 1, l, r)); &#125;&#125; tr1, tr2;int main() &#123; n = rd(), m = rd(); rep(i, 1, n) &#123; w[i] = rd(), a[i] = rd(); tr1.update(i, w[i], a[i]), tr2.update(i, w[i], 1); Ans = Mod(Ans + tr1.query(i - 1, w[i], n)), Ans = Mod(Ans + 1ll * tr2.query(i - 1, w[i], n) * a[i] % mod); &#125; rep(i, 1, m) &#123; int x = rd(), y = rd(); if (x &gt; y) swap(x, y); if (x==y) &#123;wrt(Ans,'\n');continue;&#125; Ans = Mod(Ans - tr1.query(x + 1, y - 1, w[y], n)); Ans = Mod(Ans + tr1.query(x + 1, y - 1, w[x], n)); Ans = Mod(Ans - tr1.query(x + 1, y - 1, 1, w[x])); Ans = Mod(Ans + tr1.query(x + 1, y - 1, 1, w[y])); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, w[y], n) * a[y] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, w[x], n) * a[x] % mod); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, 1, w[x]) * a[x] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, 1, w[y]) * a[y] % mod); if (w[x] &gt; w[y]) Ans -= a[x] + a[y]; else Ans += a[x] + a[y]; Ans=Mod(Ans); tr1.update(x, w[x], -a[x]), tr1.update(x, w[y], a[y]); tr1.update(y, w[y], -a[y]), tr1.update(y, w[x], a[x]); tr2.update(x, w[x], -1), tr2.update(x, w[y], 1); tr2.update(y, w[y], -1), tr2.update(y, w[x], 1); swap(w[x], w[y]), swap(a[x], a[y]); wrt(Ans, '\n'); &#125; //wrt(xtree::cnt,'\n');&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学树套树]]></title>
    <url>%2F2018%2F12%2F05%2Ftree-tao-tree%2F</url>
    <content type="text"><![CDATA[最近写了点树套树，感觉也没那么可怕 主要思想很多用于动态维护区间的一些东西，比如：区间内大于等于x的数的个数、区间前驱后继等等 主要思想很简单，就是 对外层树的每一个节点建一个内层树 具体实现方式可见例题 来几个 栗子K大数查询二逼平衡树不勤劳的图书管理员先写到这里吧]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K大数查询]]></title>
    <url>%2F2018%2F12%2F03%2Fluogu-3759%2F</url>
    <content type="text"><![CDATA[模板题 题目链接 因为有区间修改，所以外层建权值线段树，内层建区间树 处理修改：对所有包含c的外层树节点所对应的内层树的a~b区间+1 处理询问：在外层树上二分，若当前节点的右子树的内层树a~b区间和&gt;c就往左子树走，否则往右 注意: 区间树要标记永久化，不然如果写的不够优秀会 MLE or TLE 此题luogu上时限只有1s，大部分代码包括本人代码会被卡常，获得0~100不等的分数。 在往左子树走时要减掉右子树a~b区间和带来的贡献 在具体实现的时候，我为了图方便用了指针和namespace 如果你看不懂指针，可以往下翻，有无指针的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* Author: zxy_hhhh date: 2018/12/01*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define mid ((l + r) &gt;&gt; 1)int n, m;namespace xtree &#123;struct node &#123; int lazy; ll sum; node *ls, *rs;&#125;;void insert(node *&amp;u, int l, int r, int ql, int qr) &#123; if (u == NULL) u = new node; if (ql == l &amp;&amp; r == qr) &#123; u-&gt;lazy++, u-&gt;sum += r - l + 1; return; &#125; u-&gt;sum += qr - ql + 1; if (qr &lt;= mid) insert(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) insert(u-&gt;rs, mid + 1, r, ql, qr); else insert(u-&gt;ls, l, mid, ql, mid), insert(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;ll query(node *u, int l, int r, int ql, int qr) &#123; if (u == NULL) return 0; if (ql == l &amp;&amp; qr == r) return u-&gt;sum; ll ans = (qr - ql + 1) * u-&gt;lazy; if (qr &lt;= mid) return ans + query(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) return ans + query(u-&gt;rs, mid + 1, r, ql, qr); else return query(u-&gt;ls, l, mid, ql, mid) + ans + query(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;&#125;; // namespace xtreenamespace ytree &#123;struct node &#123; xtree::node *rt;&#125; tr[400005];void insert(int pos, int l, int r, int ql, int qr, int x) &#123; xtree::insert(tr[pos].rt, 1, n, ql, qr); if (l == r) return; if (x &lt;= mid) insert(pos &lt;&lt; 1, l, mid, ql, qr, x); else insert(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;int query(int pos, int l, int r, int ql, int qr, ll x) &#123; if (l == r) return l; ll sum = xtree::query(tr[pos &lt;&lt; 1 | 1].rt, 1, n, ql, qr); if (sum &gt;= x) return query(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x); else return query(pos &lt;&lt; 1, l, mid, ql, qr, x - sum);&#125;&#125;; // namespace ytreestruct Query &#123; int op, l, r; ll c;&#125; Q[maxn];int H[maxn], tot;int main() &#123; n = rd(), m = rd(); rep(i, 1, m) &#123; int op = rd(), l = rd(), r = rd(); ll x = rd(); if (op == 1) ytree::insert(1, -n, n, l, r, x); if (op == 2) wrt(ytree::query(1, -n, n, l, r, x), '\n'); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二逼平衡树]]></title>
    <url>%2F2018%2F12%2F03%2Fbzoj3196%2F</url>
    <content type="text"><![CDATA[码量稍微有大，不过思路清晰还是好写的 题目链接 外层线段树，内层平衡树 操作1 4 5就是在线段树上取出区间，然后平衡树内求答案，合并答案 修改也没什么好讲的，和上一题比较相似 操作2要二分答案，然后转化为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* Author: zxy_hhhh date: 2018/12/03*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define inf 2147483647#define mid ( (l + r) &gt;&gt; 1 int a[maxn], n, m;namespace xtree &#123;struct node *nil;struct node &#123; int sz, val, fix; node *ls, *rs; node(int x) : sz(1), val(x), fix(rand()) &#123; ls = rs = nil; &#125; inline void update() &#123; sz = ls-&gt;sz + rs-&gt;sz + 1; &#125;&#125;;inline void init() &#123; nil = new node(0); nil-&gt;ls = nil-&gt;rs = nil; nil-&gt;sz = 0;&#125;void split(node *now, int k, node *&amp;x, node *&amp;y, int op = 1) &#123; if (now == nil) &#123; x = y = nil; return; &#125; if (op == 1 ? now-&gt;val &lt; k : now-&gt;ls-&gt;sz &lt; k) &#123; x = now; split(now-&gt;rs, (op == 1 ? k : k - now-&gt;ls-&gt;sz - 1), x-&gt;rs, y, op); x-&gt;update(); &#125; else &#123; y = now; split(now-&gt;ls, k, x, y-&gt;ls, op); y-&gt;update(); &#125;&#125;node *merge(node *x, node *y) &#123; if (x == nil) return y; if (y == nil) return x; if (x-&gt;fix &lt; y-&gt;fix) &#123; x-&gt;rs = merge(x-&gt;rs, y); return x-&gt;update(), x; &#125; else &#123; y-&gt;ls = merge(x, y-&gt;ls); return y-&gt;update(), y; &#125;&#125;inline void insert(node *&amp;rt, int val) &#123; node *x, *y; split(rt, val, x, y); rt = merge(x, merge(new node(val), y));&#125;inline void del(node *&amp;rt, int val) &#123; node *x, *y, *z; split(rt, val, x, y); split(y, 1, y, z, 2); rt = merge(x, z);&#125;inline int pre(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val, x, y), split(x, x-&gt;sz - 1, x, z, 2); if (z == nil) ans = -inf; else ans = (z-&gt;val); rt = merge(x, merge(z, y)); return ans;&#125;inline int nxt(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val + 1, x, y), split(y, 1, y, z, 2); if (y == nil) ans = inf; else ans = y-&gt;val; rt = merge(x, merge(y, z)); return ans;&#125;inline int rank(node *&amp;rt, int val) &#123; node *x, *y; int ans; split(rt, val, x, y); if (x == nil) ans = 0; else ans = x-&gt;sz; rt = merge(x, y); return ans;&#125;&#125; // namespace xtreenamespace ytree &#123;xtree::node *tr[maxn &lt;&lt; 2];inline int pre(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return -inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::pre(tr[pos], x); return max(pre(pos &lt;&lt; 1, l, mid, ql, qr, x), pre(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int nxt(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::nxt(tr[pos], x); return min(nxt(pos &lt;&lt; 1, l, mid, ql, qr, x), nxt(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int rank(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::rank(tr[pos], x); return rank(pos &lt;&lt; 1, l, mid, ql, qr, x) + rank(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;inline void change(int pos, int l, int r, int x, int v) &#123; xtree::del(tr[pos], a[x]), xtree::insert(tr[pos], v); if (l == r) return; if (x &lt;= mid) change(pos &lt;&lt; 1, l, mid, x, v); else change(pos &lt;&lt; 1 | 1, mid + 1, r, x, v);&#125;inline int atrank(int L, int R, int k) &#123; int l = 0, r = 100000000, ans; while (l &lt;= r) &#123; if (rank(1, 1, n, L, R, mid) &lt; k) ans = mid, l = mid + 1; else r = mid - 1; &#125; return ans;&#125;void build(int pos, int l, int r) &#123; tr[pos] = xtree::nil; rep(i, l, r) xtree::insert(tr[pos], a[i]); if (l == r) return; build(pos &lt;&lt; 1, l, mid), build(pos &lt;&lt; 1 | 1, mid + 1, r);&#125;&#125; // namespace ytreeint main() &#123; n = rd(); m = rd(); xtree::init(); rep(i, 1, n) a[i] = rd(); ytree::build(1, 1, n); rep(i, 1, m) &#123; int op = rd(); if (op == 1) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::rank(1, 1, n, l, r, x) + 1, '\n'); &#125; else if (op == 2) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::atrank(l, r, x), '\n'); &#125; else if (op == 3) &#123; int x = rd(), k = rd(); ytree::change(1, 1, n, x, k); a[x] = k; &#125; else if (op == 4) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::pre(1, 1, n, l, r, x), '\n'); &#125; else if (op == 5) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::nxt(1, 1, n, l, r, x), '\n'); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F11%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[暂时当更新日志用12.4 8:54 update头像好像出了点锅，先拿默认的顶一顶，争取晚上解决吧;其他基本解决12.5 15:53 update因为晚上断网了，所以头像咕咕咕了；我还是先写点东西吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[ss]]></title>
    <url>%2F1028%2F12%2F06%2Fmy-ss%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
  </entry>
</search>
