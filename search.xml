<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树套树]]></title>
    <url>%2F2018%2F12%2F05%2Ftree-tao-tree%2F</url>
    <content type="text"><![CDATA[最近写了点树套树，感觉也没那么可怕 主要思想很多用于动态维护区间的一些东西，比如：区间内大于等于x的数的个数、区间前驱后继等等 主要思想很简单，就是 对外层树的每一个节点建一个内层树 具体实现方式可见例题 来几个 栗子K大数查询因为有区间修改，所以外层建权值线段树，内层建区间树 处理修改：对所有包含c的外层树节点所对应的内层树的a~b区间+1 处理询问：在外层树上二分，若当前节点的右子树的内层树a~b区间和&gt;c就往左子树走，否则往右 注意: 区间树要标记永久化，不然如果写的不够优秀会 MLE or TLE 此题luogu上时限只有1s，大部分代码包括本人代码会被卡常，获得0~100不等的分数。 在往左子树走时要减掉右子树a~b区间和带来的贡献 在具体实现的时候，我为了图方便用了指针和namespace 如果你看不懂指针，可以往下翻，有无指针的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* Author: zxy_hhhh date: 2018/12/01*/#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rep(x, a, b) for (int x = int(a); x &lt;= (int)(b); x++)#define drp(x, a, b) for (int x = int(a); x &gt;= (int)(b); x--)#define cross(x, a) for (int x = hd[a]; x; x = nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define mid ((l + r) &gt;&gt; 1)int n, m;namespace xtree &#123;struct node &#123; int lazy; ll sum; node *ls, *rs;&#125;;void insert(node *&amp;u, int l, int r, int ql, int qr) &#123; if (u == NULL) u = new node; if (ql == l &amp;&amp; r == qr) &#123; u-&gt;lazy++, u-&gt;sum += r - l + 1; return; &#125; u-&gt;sum += qr - ql + 1; if (qr &lt;= mid) insert(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) insert(u-&gt;rs, mid + 1, r, ql, qr); else insert(u-&gt;ls, l, mid, ql, mid), insert(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;ll query(node *u, int l, int r, int ql, int qr) &#123; if (u == NULL) return 0; if (ql == l &amp;&amp; qr == r) return u-&gt;sum; ll ans = (qr - ql + 1) * u-&gt;lazy; if (qr &lt;= mid) return ans + query(u-&gt;ls, l, mid, ql, qr); else if (ql &gt; mid) return ans + query(u-&gt;rs, mid + 1, r, ql, qr); else return query(u-&gt;ls, l, mid, ql, mid) + ans + query(u-&gt;rs, mid + 1, r, mid + 1, qr);&#125;&#125;; // namespace xtreenamespace ytree &#123;struct node &#123; xtree::node *rt;&#125; tr[400005];void insert(int pos, int l, int r, int ql, int qr, int x) &#123; xtree::insert(tr[pos].rt, 1, n, ql, qr); if (l == r) return; if (x &lt;= mid) insert(pos &lt;&lt; 1, l, mid, ql, qr, x); else insert(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;int query(int pos, int l, int r, int ql, int qr, ll x) &#123; if (l == r) return l; ll sum = xtree::query(tr[pos &lt;&lt; 1 | 1].rt, 1, n, ql, qr); if (sum &gt;= x) return query(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x); else return query(pos &lt;&lt; 1, l, mid, ql, qr, x - sum);&#125;&#125;; // namespace ytreestruct Query &#123; int op, l, r; ll c;&#125; Q[maxn];int H[maxn], tot;int main() &#123; n = rd(), m = rd(); rep(i, 1, m) &#123; int op = rd(), l = rd(), r = rd(); ll x = rd(); if (op == 1) ytree::insert(1, -n, n, l, r, x); if (op == 2) wrt(ytree::query(1, -n, n, l, r, x), '\n'); &#125;&#125; 二逼平衡树外层线段树，内层平衡树 操作1 4 5就是在线段树上取出区间，然后平衡树内求答案，合并答案 修改也没什么好讲的，和上一题比较相似 操作2要二分答案，然后转化为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* Author: zxy_hhhh date: 2018/12/03*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define maxn 50005#define inf 2147483647#define mid ( (l + r) &gt;&gt; 1 int a[maxn], n, m;namespace xtree &#123;struct node *nil;struct node &#123; int sz, val, fix; node *ls, *rs; node(int x) : sz(1), val(x), fix(rand()) &#123; ls = rs = nil; &#125; inline void update() &#123; sz = ls-&gt;sz + rs-&gt;sz + 1; &#125;&#125;;inline void init() &#123; nil = new node(0); nil-&gt;ls = nil-&gt;rs = nil; nil-&gt;sz = 0;&#125;void split(node *now, int k, node *&amp;x, node *&amp;y, int op = 1) &#123; if (now == nil) &#123; x = y = nil; return; &#125; if (op == 1 ? now-&gt;val &lt; k : now-&gt;ls-&gt;sz &lt; k) &#123; x = now; split(now-&gt;rs, (op == 1 ? k : k - now-&gt;ls-&gt;sz - 1), x-&gt;rs, y, op); x-&gt;update(); &#125; else &#123; y = now; split(now-&gt;ls, k, x, y-&gt;ls, op); y-&gt;update(); &#125;&#125;node *merge(node *x, node *y) &#123; if (x == nil) return y; if (y == nil) return x; if (x-&gt;fix &lt; y-&gt;fix) &#123; x-&gt;rs = merge(x-&gt;rs, y); return x-&gt;update(), x; &#125; else &#123; y-&gt;ls = merge(x, y-&gt;ls); return y-&gt;update(), y; &#125;&#125;inline void insert(node *&amp;rt, int val) &#123; node *x, *y; split(rt, val, x, y); rt = merge(x, merge(new node(val), y));&#125;inline void del(node *&amp;rt, int val) &#123; node *x, *y, *z; split(rt, val, x, y); split(y, 1, y, z, 2); rt = merge(x, z);&#125;inline int pre(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val, x, y), split(x, x-&gt;sz - 1, x, z, 2); if (z == nil) ans = -inf; else ans = (z-&gt;val); rt = merge(x, merge(z, y)); return ans;&#125;inline int nxt(node *&amp;rt, int val) &#123; node *x, *y, *z; int ans; split(rt, val + 1, x, y), split(y, 1, y, z, 2); if (y == nil) ans = inf; else ans = y-&gt;val; rt = merge(x, merge(y, z)); return ans;&#125;inline int rank(node *&amp;rt, int val) &#123; node *x, *y; int ans; split(rt, val, x, y); if (x == nil) ans = 0; else ans = x-&gt;sz; rt = merge(x, y); return ans;&#125;&#125; // namespace xtreenamespace ytree &#123;xtree::node *tr[maxn &lt;&lt; 2];inline int pre(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return -inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::pre(tr[pos], x); return max(pre(pos &lt;&lt; 1, l, mid, ql, qr, x), pre(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int nxt(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return inf; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::nxt(tr[pos], x); return min(nxt(pos &lt;&lt; 1, l, mid, ql, qr, x), nxt(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x));&#125;inline int rank(int pos, int l, int r, int ql, int qr, int x) &#123; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return x = xtree::rank(tr[pos], x); return rank(pos &lt;&lt; 1, l, mid, ql, qr, x) + rank(pos &lt;&lt; 1 | 1, mid + 1, r, ql, qr, x);&#125;inline void change(int pos, int l, int r, int x, int v) &#123; xtree::del(tr[pos], a[x]), xtree::insert(tr[pos], v); if (l == r) return; if (x &lt;= mid) change(pos &lt;&lt; 1, l, mid, x, v); else change(pos &lt;&lt; 1 | 1, mid + 1, r, x, v);&#125;inline int atrank(int L, int R, int k) &#123; int l = 0, r = 100000000, ans; while (l &lt;= r) &#123; if (rank(1, 1, n, L, R, mid) &lt; k) ans = mid, l = mid + 1; else r = mid - 1; &#125; return ans;&#125;void build(int pos, int l, int r) &#123; tr[pos] = xtree::nil; rep(i, l, r) xtree::insert(tr[pos], a[i]); if (l == r) return; build(pos &lt;&lt; 1, l, mid), build(pos &lt;&lt; 1 | 1, mid + 1, r);&#125;&#125; // namespace ytreeint main() &#123; n = rd(); m = rd(); xtree::init(); rep(i, 1, n) a[i] = rd(); ytree::build(1, 1, n); rep(i, 1, m) &#123; int op = rd(); if (op == 1) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::rank(1, 1, n, l, r, x) + 1, '\n'); &#125; else if (op == 2) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::atrank(l, r, x), '\n'); &#125; else if (op == 3) &#123; int x = rd(), k = rd(); ytree::change(1, 1, n, x, k); a[x] = k; &#125; else if (op == 4) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::pre(1, 1, n, l, r, x), '\n'); &#125; else if (op == 5) &#123; int l = rd(), r = rd(), x = rd(); wrt(ytree::nxt(1, 1, n, l, r, x), '\n'); &#125; &#125;&#125; 不勤劳的图书管理员暴力可以AC 先算出不修改时的答案； 对于的位置i贡献就是 $\Sigma_{j=1}^{j&lt;i} a[j]+a[i] (v[j]&gt;v[i])$ 然后对于每一次修改，考虑对答案的影响就是y移到x减少的和x移到y增加的而影响只会出现在(x,y) 具体就是： (x,y)对x产生的逆序对，y对(x,y)产生的逆序对会失去 (x,y)对y产生的逆序对，x对(x,y)产生的逆序对会增加入答案 如何维护a[i]+a[j]? 用树套树维护(x,y)大于等于x的数的个数和这些数的和 不能用指针，不然空间会GG 要外层树状数组内层线段树，不然空间GG 外层线段树内层平衡树空间OK的，不过时间就呵呵了机房某大佬卡了一上午常之后彻底弃疗，写了暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* Author: zxy_hhhh date: 2018/12/05*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define rep(x,a,b) for (int x=int(a);x&lt;=(int)(b);x++)#define drp(x,a,b) for (int x=int(a);x&gt;=(int)(b);x--)#define cross(x,a) for (int x=hd[a];x;x=nx[x])#define ll long longusing namespace std;inline ll rd()&#123; ll _x=0;int _ch=getchar(),_f=1; for(;!isdigit(_ch)&amp;&amp;(_ch!='-')&amp;&amp;(_ch!=EOF);_ch=getchar()); if (_ch=='-')&#123;_f=0;_ch=getchar();&#125; for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0'; return _f?_x:-_x;&#125;void write(ll _x)&#123;if (_x&gt;=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); &#125;inline void wrt(ll _x,char _p)&#123;if (_x&lt;0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);&#125;#define mod 1000000007#define mid ((l + r) &gt;&gt; 1)#define lb(x) (x &amp; -x)#define maxn 50005int n, a[maxn], w[maxn], m, Ans;inline int Mod(int x) &#123; return x &lt; 0 ? (x + mod) : (x &gt;= mod ? x - mod : x); &#125;namespace xtree &#123;struct node &#123; int sum,ls,rs;&#125;tr[20000000];int cnt;void insert(int &amp;u, int l, int r, int x, int k) &#123; if (!u) u = ++cnt; tr[u].sum = Mod(tr[u].sum + k); if (l == r) return; if (x &lt;= mid) insert(tr[u].ls, l, mid, x, k); else insert(tr[u].rs, mid + 1, r, x, k);&#125;inline int query(int u, int l, int r, int ql, int qr) &#123; if (!u) return 0; if (r &lt; ql || l &gt; qr) return 0; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tr[u].sum; return (query(tr[u].ls, l, mid, ql, qr) + query(tr[u].rs, mid + 1, r, ql, qr)) % mod;&#125;&#125; // namespace xtreestruct &#123; int tr[maxn]; inline void update(int x, int k, int val) &#123; for (; x &lt;= n; x += lb(x)) xtree::insert(tr[x], 1, n, k, val); &#125; inline int query(int x, int L, int R) &#123; int ans = 0; for (; x; x -= lb(x)) ans = Mod(ans + xtree::query(tr[x], 1, n, L, R)); return ans; &#125; inline int query(int L, int R, int l, int r) &#123; return Mod(query(R, l, r) - query(L - 1, l, r)); &#125;&#125; tr1, tr2;int main() &#123; n = rd(), m = rd(); rep(i, 1, n) &#123; w[i] = rd(), a[i] = rd(); tr1.update(i, w[i], a[i]), tr2.update(i, w[i], 1); Ans = Mod(Ans + tr1.query(i - 1, w[i], n)), Ans = Mod(Ans + 1ll * tr2.query(i - 1, w[i], n) * a[i] % mod); &#125; rep(i, 1, m) &#123; int x = rd(), y = rd(); if (x &gt; y) swap(x, y); if (x==y) &#123;wrt(Ans,'\n');continue;&#125; Ans = Mod(Ans - tr1.query(x + 1, y - 1, w[y], n)); Ans = Mod(Ans + tr1.query(x + 1, y - 1, w[x], n)); Ans = Mod(Ans - tr1.query(x + 1, y - 1, 1, w[x])); Ans = Mod(Ans + tr1.query(x + 1, y - 1, 1, w[y])); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, w[y], n) * a[y] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, w[x], n) * a[x] % mod); Ans = Mod(Ans - 1ll * tr2.query(x + 1, y - 1, 1, w[x]) * a[x] % mod); Ans = Mod(Ans + 1ll * tr2.query(x + 1, y - 1, 1, w[y]) * a[y] % mod); if (w[x] &gt; w[y]) Ans -= a[x] + a[y]; else Ans += a[x] + a[y]; Ans=Mod(Ans); tr1.update(x, w[x], -a[x]), tr1.update(x, w[y], a[y]); tr1.update(y, w[y], -a[y]), tr1.update(y, w[x], a[x]); tr2.update(x, w[x], -1), tr2.update(x, w[y], 1); tr2.update(y, w[y], -1), tr2.update(y, w[x], 1); swap(w[x], w[y]), swap(a[x], a[y]); wrt(Ans, '\n'); &#125; //wrt(xtree::cnt,'\n');&#125; 先写到这里吧]]></content>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F11%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[暂时当更新日志用12.4 8:54 update头像好像出了点锅，先拿默认的顶一顶，争取晚上解决吧;其他基本解决12.5 15:53 update因为晚上断网了，所以头像咕咕咕了；我还是先写点东西吧]]></content>
  </entry>
</search>
